{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/mojikura-sfx-choicy-formulas-with-multiple-expansions.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n'use strict'\n\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'CHOICY-FORMULAS'\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\ninfo                      = CND.get_logger 'info',      badge\nurge                      = CND.get_logger 'urge',      badge\nhelp                      = CND.get_logger 'help',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\necho                      = CND.echo.bind CND\n#...........................................................................................................\ntypes                     = new ( require 'intertype' ).Intertype()\n{ isa\n  validate }              = types.export()\n\n###\n\n# Original Code Comment from `mojikura3-model/db/245-sfx.sql`:\n\n\nA **Choicy Formula** (*cFormula*) is a formula in which alternative resolutions have been made explicit.\nFor example, glyph u-cjk-xa/3b79 㭹 can be equivalently described as either `⿰木弦` or as\n`⿰杛玄`; we notate these possibilities in a single Choicy Formula as `{㭹|⿰木弦|⿰杛玄}`.\nBoth of these formulas are classed as *Short Formulas*, or *sFormulas*, because both represent\nways to decompose the glpyh in question into a minimal number of formula parts.\n\nA Choicy Formula always starts with the glyph itself as the first choice, and then lists\nall of the alternative decompositions, separated by `|` pipe symbols.\n\nChoicy formulas can be expanded by substituting all decomposable elements by their respective\nChoicy Formulas. Since `弦` and `杛` can be decomposed into `{弦|⿰弓玄}` and `{杛|⿰木弓}`,\na deeper representation of 㭹 can be written as `{㭹|⿰木{弦|⿰弓玄}|⿰{杛|⿰木弓}玄}`.\n\nNotice how Choicy Formulas, unlike 'destructive' element substitutions, presevere the intermediate\nsteps and the identities of the substituted formula constituents; hence, it is possible\nto not only reconstruct the sFormula(s) of the glyph described, but also (from a fully resolved\nChoicy Formula), its *Factorial Formula* (*fFormula*) and, crucially, all well-formed\nintermediate IDL decompositions of the glyph. This functionality is provided by function\n`SFX.expand( glyph, cformula )`. In the simple case, seemingly nothing of interest gets added to our\ninput, and we get (edited for readablity; actual return value is a list):\n\n```\nselect SFX.expand( '㭹', '{㭹|⿰木{弦|⿰弓玄}|⿰{杛|⿰木弓}玄}' ); ->\n\n㭹\n⿰杛玄\n⿰木弦\n⿰⿰木弓玄\n⿰木⿰弓玄\n```\n\n> Note that `SFX.expand()` does not (yet) perform formula normalization; with formula normalization\n> applied, the last two decompositions would both turn into `(⿰木弓玄)`, and the function\n> would return a list of 4 instead of 5 items.\n\nLet's add some depth to our cFormula and see what happens. A:uc0---:007384:玄 *Arcanum* is classified as a\nFactor and most of the time, we will persue decompositions no further than down to the level of factors.\nIf we were to decompose 玄, however, we'd find that there are three obvious ways to assemble 玄 from\nsmaller parts, *viz.* ⿱亠幺 (the most obvious one), ⿱丶𢆰 (which is equally valid), and ⿰𤣥丶 (a little\nmore contrived, but not without historical significance, see 𤣥 *Arcanum attenuatissimum*); therefore,\nwe have `{玄|⿱亠幺|⿱丶𢆰|⿰𤣥丶}`, and substituting this into the above cFormula for 㭹 gives us\n{㭹|⿰木{弦|⿰弓{玄|⿱亠幺|⿱丶𢆰|⿰𤣥丶}}|⿰{杛|⿰木弓}{玄|⿱亠幺|⿱丶𢆰|⿰𤣥丶}}. Expansion\n(and normalization) turns this into:\n\n```\n㭹\n⿰木弦\n(⿰木弓玄)\n(⿰木弓⿱亠幺)\n(⿰木弓⿱丶𢆰)\n(⿰木弓𤣥丶)\n⿰杛玄\n⿰杛⿱亠幺\n⿰杛⿱丶𢆰\n(⿰杛𤣥丶)\n```\n\nThe beauty of this rather exhaustive, nine-fold decomposition of our glyph 㭹 lies in the fact\nthat we can derive a similarly exhaustive set of **Relational Bigrams** (*rbGrams*) from the\nformulas:\n\n```\n⿰弓丶\n⿰弓亠\n⿰弓玄\n⿰弓𤣥\n⿰木弓\n⿰木弦\n⿰杛丶\n⿰杛亠\n⿰杛玄\n⿰杛𤣥\n⿰𤣥丶\n⿱丶𢆰\n⿱亠幺\n```\n\nRelational Bigrams afford an X-ray like peek into (some local details in) the inner makeup of characters;\nthus, the central part of 㭹 shows 弓 *Arcus* to the left of 𤣥 *Arcanum attenuatissimum*, and the\nrbGram ⿰弓𤣥 captures this bit of detail.\n\n###\n\n#===========================================================================================================\nclass @XXX extends Array\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( P... ) ->\n    super()\n    for p in P\n      @push p\n    return undefined\n\nclass @Glyph extends @XXX\nclass @Formulas extends @XXX\nclass @Formula extends @XXX\n\n#-----------------------------------------------------------------------------------------------------------\n@demo = ->\n  # debug '^4575^', new @X '㭹', [ '⿰杛玄', '⿰木弦', ]\n  registry          = []\n  # registry[ '㭹' ]  = new @Glyph '㭹', ( @Formula.from '⿰杛玄' ), ( @Formula.from '⿰木弦' )\n  # registry[ '弦' ]  = new @Glyph '弦', ( @Formula.from '⿰弓玄' )\n  # registry[ '杛' ]  = new @Glyph '杛', ( @Formula.from '⿰木弓' )\n  # registry[ '玄' ]  = new @Glyph '玄', ( @Formula.from '⿱亠幺' ), ( @Formula.from '⿱丶𢆰' ), ( @Formula.from '⿰𤣥丶' )\n  # registry[ '㭹' ]  = new @Glyph '㭹', new @Formulas ( @Formula.from '⿰杛玄' ), ( @Formula.from '⿰木弦' )\n  # registry[ '弦' ]  = new @Glyph '弦', new @Formulas ( @Formula.from '⿰弓玄' )\n  # registry[ '杛' ]  = new @Glyph '杛', new @Formulas ( @Formula.from '⿰木弓' )\n  # registry[ '玄' ]  = new @Glyph '玄', new @Formulas ( @Formula.from '⿱亠幺' ), ( @Formula.from '⿱丶𢆰' ), ( @Formula.from '⿰𤣥丶' )\n\n#-----------------------------------------------------------------------------------------------------------\n@string_demo = ->\n  IDLX              = require '../../../../../io/mingkwai-rack/mojikura-idl'\n  non_components    = new Set Array.from \"|()[]{}§'≈'●⿰⿱⿲⿳⿴⿵⿶⿷⿸⿹⿺⿻〓≈ ↻↔ ↕ ▽\"\n  registry          = {}\n  registry[ '弦' ]  = '{弦|⿰弓玄}'\n  registry[ '杛' ]  = '{杛|⿰木弓}'\n  registry[ '木' ]  = '{木|⿻十人}'\n  registry[ '㭹' ]  = '{㭹|⿰杛玄|⿰木弦}'\n  registry[ '十' ]  = '{十|⿻一丨}'\n  registry[ '人' ]  = '{人|⿰丿㇏}'\n  registry[ '玄' ]  = '{玄|⿱亠幺|⿱丶𢆰|⿰𤣥丶}'\n  for glyph, cformula of registry\n    chrs = Array.from cformula\n    # info '^558^', glyph, cformula\n    loop\n      count = 0\n      for idx in [ 3 ... chrs.length - 1 ]\n        chr = chrs[ idx ]\n        continue if non_components.has chr\n        continue unless ( rcformula = registry[ chr ] )?\n        count++\n        chrs.splice idx, 1, Array.from rcformula\n      break if count is 0\n    registry[ glyph ] = chrs = chrs.flat().join ''\n  for glyph, cformula of registry\n    urge '^443^', glyph, cformula\n    components = new Set()\n    for rcformula in @SFX_expand glyph, cformula\n      for component in [ cformula..., ]\n        continue if component is glyph\n        continue if non_components.has component\n        components.add component\n      help '^443^', glyph, rcformula\n    info '^4568^', glyph, [ components..., ].join ''\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\n@SFX_expand = ( glyph, cformula ) ->\n  # declare\n  collector      = null                  # text[];\n  cformulas      = [ cformula, ]        # text[]  :=  array[ cformula ];\n  term_pattern   = ///(?<term>\\{[^{}]+\\})///u   # text    :=  '\\{[^{}}]+\\}';\n  match           = null\n  term           = null                  # text;\n  position       = null                  # integer;\n  prefix         = null                  # text;\n  suffix         = null                  # text;\n  choice         = null                  # text;\n  choices        = null                  # text[];\n  hint           = ''                    # text    :=  '';\n  new_formula    = null                  # text;\n  #.........................................................................................................\n  # begin\n  loop\n    collector = []\n    #.......................................................................................................\n    for cformula in cformulas\n      #.....................................................................................................\n      if ( match = cformula.match term_pattern )?\n        term         = match.groups.term\n        # debug '^222^', rpr term\n        position     = cformula.indexOf term\n        prefix       = if position is 0 then '' else cformula[ 0 .. position - 1 ]\n        suffix       = cformula[ position + term.length .. ] ? ''\n        choices      = term[ 1 .. term.length - 2 ].split '|'\n        # urge '^44472^', { cformula, position, }\n        # urge '^44472^', { prefix, term, suffix, }\n        # urge '^44472^', { choices, }\n        #...................................................................................................\n        for choice in choices\n          new_formula  = prefix + choice + suffix\n          # debug '^33423^', glyph, new_formula\n          # debug '^33423^', glyph, collector\n          # if not array[ new_formula ] <@ collector then\n          # if false\n          collector.push new_formula\n    #.......................................................................................................\n    if collector.length is 0\n      return Array.from new Set cformulas\n    #.......................................................................................................\n    # cformulas = U.array_unique( collector );\n    cformulas = Array.from new Set collector\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\n@list_demo = ->\n  registry          = {}\n  registry[ '㭹' ]  = [ '㭹', [ '⿰杛玄'..., ], [ '⿰木弦'..., ], ]\n  registry[ '弦' ]  = [ '弦', [ '⿰弓玄'..., ], ]\n  registry[ '杛' ]  = [ '杛', [ '⿰木弓'..., ], ]\n  registry[ '玄' ]  = [ '玄', [ '⿱亠幺'..., ], [ '⿱丶𢆰'..., ], [ '⿰𤣥丶'..., ], ]\n  registry[ '木' ]  = [ '木', [ '⿻十人'..., ], ]\n  for glyph, d of registry\n    [ _, formulas..., ] = d\n    urge '^589^', glyph\n    for formula in formulas\n      whisper '^589^  ', formula\n      for element, idx in formula\n        continue unless ( d = registry[ element ] )?\n        whisper '^589^    ', d\n        formula[ idx ] = d\n      info '^589^  ', formula\n  # for x, idx in d\n  #   if idx is 0\n  #   if\n  return null\n\n\n############################################################################################################\nif module is require.main then do =>\n  # await @list_demo()\n  await @string_demo()\n\n\n\n\n\n"
  ]
}