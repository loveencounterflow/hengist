{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/mojikura-sfx-choicy-formulas-with-multiple-expansions.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n'use strict'\n\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'CHOICY-FORMULAS'\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\ninfo                      = CND.get_logger 'info',      badge\nurge                      = CND.get_logger 'urge',      badge\nhelp                      = CND.get_logger 'help',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\necho                      = CND.echo.bind CND\n#...........................................................................................................\ntypes                     = new ( require 'intertype' ).Intertype()\n{ isa\n  validate }              = types.export()\n\n###\n\n# Original Code Comment from `mojikura3-model/db/245-sfx.sql`:\n\n\nA **Choicy Formula** (*cFormula*) is a formula in which alternative resolutions have been made explicit.\nFor example, glyph u-cjk-xa/3b79 㭹 can be equivalently described as either `⿰木弦` or as\n`⿰杛玄`; we notate these possibilities in a single Choicy Formula as `{㭹|⿰木弦|⿰杛玄}`.\nBoth of these formulas are classed as *Short Formulas*, or *sFormulas*, because both represent\nways to decompose the glpyh in question into a minimal number of formula parts.\n\nA Choicy Formula always starts with the glyph itself as the first choice, and then lists\nall of the alternative decompositions, separated by `|` pipe symbols.\n\nChoicy formulas can be expanded by substituting all decomposable elements by their respective\nChoicy Formulas. Since `弦` and `杛` can be decomposed into `{弦|⿰弓玄}` and `{杛|⿰木弓}`,\na deeper representation of 㭹 can be written as `{㭹|⿰木{弦|⿰弓玄}|⿰{杛|⿰木弓}玄}`.\n\nNotice how Choicy Formulas, unlike 'destructive' element substitutions, presevere the intermediate\nsteps and the identities of the substituted formula constituents; hence, it is possible\nto not only reconstruct the sFormula(s) of the glyph described, but also (from a fully resolved\nChoicy Formula), its *Factorial Formula* (*fFormula*) and, crucially, all well-formed\nintermediate IDL decompositions of the glyph. This functionality is provided by function\n`SFX.expand( glyph, cformula )`. In the simple case, seemingly nothing of interest gets added to our\ninput, and we get (edited for readablity; actual return value is a list):\n\n```\nselect SFX.expand( '㭹', '{㭹|⿰木{弦|⿰弓玄}|⿰{杛|⿰木弓}玄}' ); ->\n\n㭹\n⿰杛玄\n⿰木弦\n⿰⿰木弓玄\n⿰木⿰弓玄\n```\n\n> Note that `SFX.expand()` does not (yet) perform formula normalization; with formula normalization\n> applied, the last two decompositions would both turn into `(⿰木弓玄)`, and the function\n> would return a list of 4 instead of 5 items.\n\nLet's add some depth to our cFormula and see what happens. A:uc0---:007384:玄 *Arcanum* is classified as a\nFactor and most of the time, we will persue decompositions no further than down to the level of factors.\nIf we were to decompose 玄, however, we'd find that there are three obvious ways to assemble 玄 from\nsmaller parts, *viz.* ⿱亠幺 (the most obvious one), ⿱丶𢆰 (which is equally valid), and ⿰𤣥丶 (a little\nmore contrived, but not without historical significance, see 𤣥 *Arcanum attenuatissimum*); therefore,\nwe have `{玄|⿱亠幺|⿱丶𢆰|⿰𤣥丶}`, and substituting this into the above cFormula for 㭹 gives us\n{㭹|⿰木{弦|⿰弓{玄|⿱亠幺|⿱丶𢆰|⿰𤣥丶}}|⿰{杛|⿰木弓}{玄|⿱亠幺|⿱丶𢆰|⿰𤣥丶}}. Expansion\n(and normalization) turns this into:\n\n```\n㭹\n⿰木弦\n(⿰木弓玄)\n(⿰木弓⿱亠幺)\n(⿰木弓⿱丶𢆰)\n(⿰木弓𤣥丶)\n⿰杛玄\n⿰杛⿱亠幺\n⿰杛⿱丶𢆰\n(⿰杛𤣥丶)\n```\n\nThe beauty of this rather exhaustive, nine-fold decomposition of our glyph 㭹 lies in the fact\nthat we can derive a similarly exhaustive set of **Relational Bigrams** (*rbGrams*) from the\nformulas:\n\n```\n⿰弓丶\n⿰弓亠\n⿰弓玄\n⿰弓𤣥\n⿰木弓\n⿰木弦\n⿰杛丶\n⿰杛亠\n⿰杛玄\n⿰杛𤣥\n⿰𤣥丶\n⿱丶𢆰\n⿱亠幺\n```\n\nRelational Bigrams afford an X-ray like peek into (some local details in) the inner makeup of characters;\nthus, the central part of 㭹 shows 弓 *Arcus* to the left of 𤣥 *Arcanum attenuatissimum*, and the\nrbGram ⿰弓𤣥 captures this bit of detail.\n\n###\n\n#===========================================================================================================\nclass @XXX extends Array\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( P... ) ->\n    super()\n    for p in P\n      @push p\n    return undefined\n\nclass @Glyph extends @XXX\nclass @Formulas extends @XXX\nclass @Formula extends @XXX\n\n#-----------------------------------------------------------------------------------------------------------\n@demo = ->\n  # debug '^4575^', new @X '㭹', [ '⿰杛玄', '⿰木弦', ]\n  registry          = []\n  # registry[ '㭹' ]  = new @Glyph '㭹', ( @Formula.from '⿰杛玄' ), ( @Formula.from '⿰木弦' )\n  # registry[ '弦' ]  = new @Glyph '弦', ( @Formula.from '⿰弓玄' )\n  # registry[ '杛' ]  = new @Glyph '杛', ( @Formula.from '⿰木弓' )\n  # registry[ '玄' ]  = new @Glyph '玄', ( @Formula.from '⿱亠幺' ), ( @Formula.from '⿱丶𢆰' ), ( @Formula.from '⿰𤣥丶' )\n  # registry[ '㭹' ]  = new @Glyph '㭹', new @Formulas ( @Formula.from '⿰杛玄' ), ( @Formula.from '⿰木弦' )\n  # registry[ '弦' ]  = new @Glyph '弦', new @Formulas ( @Formula.from '⿰弓玄' )\n  # registry[ '杛' ]  = new @Glyph '杛', new @Formulas ( @Formula.from '⿰木弓' )\n  # registry[ '玄' ]  = new @Glyph '玄', new @Formulas ( @Formula.from '⿱亠幺' ), ( @Formula.from '⿱丶𢆰' ), ( @Formula.from '⿰𤣥丶' )\n\n#-----------------------------------------------------------------------------------------------------------\n@string_demo = ->\n  { IDL, IDLX, _NCR, } = require '../../../apps/mojikura-idl'\n  # IDLX              = require '../../../apps/mojikura-idl/lib/main'\n  # IDLX              = require 'mojikura-idl'\n  non_components    = new Set Array.from \"|()[]{}§'≈'●⿰⿱⿲⿳⿴⿵⿶⿷⿸⿹⿺⿻〓≈ ↻↔ ↕ ▽\"\n  #.........................................................................................................\n  ### establish registry ###\n  registry          = {}\n  registry[ '來' ]  = '{來|⿻木从}'\n  registry[ '木' ]  = '{木|⿻十人}'\n  registry[ '十' ]  = '{十|⿻一丨}'\n  registry[ '人' ]  = '{人|⿰丿㇏}'\n  # # registry[ '丶' ]  = '{丶|●}'\n  # registry[ '弓' ]  = '{弓|⿱&jzr#xe139;㇉}'\n  # registry[ '' ]  = '{|⿱𠃌一}'\n  # registry[ '从' ]  = '{从|⿰人人}'\n  # registry[ '幺' ]  = '{幺|⿰&jzr#xe10e;丶}'\n  # registry[ '&jzr#xe10e;' ]  = '{&jzr#xe10e;|⿱𠃋𠃋}'\n  # registry[ '𢆰' ]  = '{𢆰|⿱一幺}'\n  # registry[ '𤣥' ]  = '{𤣥|⿱亠&jzr#xe10e;}'\n  # registry[ '亠' ]  = '{亠|⿱丶一}'\n  # registry[ '玄' ]  = '{玄|⿱亠幺|⿱丶𢆰|⿰𤣥丶}'\n  # registry[ '㭹' ]  = '{㭹|⿰杛玄|⿰木弦}'\n  # registry[ '杛' ]  = '{杛|⿰木弓}'\n  # registry[ '弦' ]  = '{弦|⿰弓玄}'\n  #.........................................................................................................\n  ### normalize registry ###\n  for glyph, cformula of registry\n    if glyph.startsWith '&'\n      delete registry[ glyph ]\n      glyph             = _NCR.jzr_as_uchr glyph\n      registry[ glyph ] = cformula\n    cformula          = cformula.replace /&[^;]+;/g, ( $0 ) -> _NCR.jzr_as_uchr $0\n    registry[ glyph ] = cformula\n  #.........................................................................................................\n  ### expand cFormulas ###\n  loop\n    outer_count = 0\n    whisper '^335^', '-'.repeat 50\n    for glyph, old_cformula of registry\n      chrs = Array.from old_cformula\n      idx = 2\n      loop\n        idx++\n        break if idx >= chrs.length - 1\n        chr = chrs[ idx ]\n        continue if ( chrs[ idx - 1 ] is '{' ) and ( chrs[ idx + 1 ] is '|' )\n        continue if non_components.has chr\n        continue unless ( rcformula = registry[ chr ] )?\n        chrs.splice idx, 1, ( Array.from rcformula )...\n      new_cformula = chrs.join ''\n      if new_cformula != old_cformula\n        outer_count++\n        registry[ glyph ] = new_cformula\n      debug '^558^', outer_count, glyph, ( CND.grey old_cformula ), ( CND.lime new_cformula )\n    ### TAINT maybe looping never needed? ###\n    break if outer_count is 0\n  #.........................................................................................................\n  for glyph, cformula of registry\n    whisper '-'.repeat 50\n    urge '^443^', glyph, cformula\n    # continue if glyph is '㭹' ### !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ###\n    components = new Set()\n    for rcformula, rcf_idx in @SFX_expand glyph, cformula\n      rcf_nr = rcf_idx + 1\n      # for component in [ cformula..., ]\n      #   continue if component is glyph\n      #   continue if non_components.has component\n      #   # debug '^4477^', component, IDLX._text_with_jzr_glyphs_as_uchrs component\n      #   components.add component\n      error       = null\n      mrcformula  = null\n      #.....................................................................................................\n      try\n        ### TAINT no need to minimize short formulas ###\n        mrcformula = IDLX.minimize_formula rcformula\n      catch error\n        throw error unless error.message.startsWith 'Syntax error at index 0'\n      #.....................................................................................................\n      if ( not error? ) and ( mrcformula isnt rcformula )\n        help '^443^', rcf_nr, glyph, ( CND.lime mrcformula ), ( CND.grey rcformula )\n      else\n        help '^443^', rcf_nr, glyph, rcformula\n      local_components = ( c for c in [ ( mrcformula ? '' )..., ] when not non_components.has c )\n      components.add c for c in local_components\n    components = [ components..., ]\n    components = components.sort()\n    components = components.join ''\n    info '^4568^', glyph, components\n  #.........................................................................................................\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\n@SFX_expand = ( glyph, cformula ) ->\n  # declare\n  collector      = null                  # text[];\n  cformulas      = [ cformula, ]        # text[]  :=  array[ cformula ];\n  term_pattern   = ///(?<term>\\{[^{}]+\\})///u   # text    :=  '\\{[^{}}]+\\}';\n  match           = null\n  term           = null                  # text;\n  position       = null                  # integer;\n  prefix         = null                  # text;\n  suffix         = null                  # text;\n  choice         = null                  # text;\n  choices        = null                  # text[];\n  new_formula    = null                  # text;\n  #.........................................................................................................\n  # begin\n  count = 0\n  loop\n    collector = new Set()\n    #.......................................................................................................\n    for cformula in cformulas\n      count++\n      #.....................................................................................................\n      if ( match = cformula.match term_pattern )?\n        term         = match.groups.term\n        # position     = cformula.indexOf term\n        position     = match.index\n        prefix       = if position is 0 then '' else cformula[ 0 .. position - 1 ]\n        suffix       = cformula[ position + term.length .. ] ? ''\n        choices      = term[ 1 .. term.length - 2 ].split '|'\n        debug '^3344^', glyph, [ position, term, prefix, suffix, ]\n        # debug '^3344^', glyph, choices\n        # urge '^44472^', { cformula, position, }\n        # urge '^44472^', { prefix, term, suffix, }\n        # urge '^44472^', { choices, }\n        #...................................................................................................\n        for choice in choices\n          new_formula  = prefix + choice + suffix\n          urge '^3342^', { glyph, new_formula, }\n          # debug '^33423^', glyph, collector\n          # if not array[ new_formula ] <@ collector then\n          # if false\n          collector.add new_formula\n    #.......................................................................................................\n    # debug '^3343^', collector\n    if collector.size is 0\n      # return Array.from cformulas\n      debug '^334^', { glyph, count, }\n      return cformulas\n    #.......................................................................................................\n    # cformulas = U.array_unique( collector );\n    cformulas = Array.from collector\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\n@list_demo = ->\n  registry          = {}\n  registry[ '㭹' ]  = [ '㭹', [ '⿰杛玄'..., ], [ '⿰木弦'..., ], ]\n  registry[ '弦' ]  = [ '弦', [ '⿰弓玄'..., ], ]\n  registry[ '杛' ]  = [ '杛', [ '⿰木弓'..., ], ]\n  registry[ '玄' ]  = [ '玄', [ '⿱亠幺'..., ], [ '⿱丶𢆰'..., ], [ '⿰𤣥丶'..., ], ]\n  registry[ '木' ]  = [ '木', [ '⿻十人'..., ], ]\n  for glyph, d of registry\n    [ _, formulas..., ] = d\n    urge '^589^', glyph\n    for formula in formulas\n      whisper '^589^  ', formula\n      for element, idx in formula\n        continue unless ( d = registry[ element ] )?\n        whisper '^589^    ', d\n        formula[ idx ] = d\n      info '^589^  ', formula\n  # for x, idx in d\n  #   if idx is 0\n  #   if\n  return null\n\n\n############################################################################################################\nif module is require.main then do =>\n  # await @list_demo()\n  await @string_demo()\n\n\n\n\n\n"
  ]
}