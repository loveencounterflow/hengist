{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/async-to-sync-with-atomics-wait.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n###\n\nSee\n  * [*A future for SQL on the web*](https://lobste.rs/s/1ylnel/future_for_sql_on_web)\n  * [*A future for SQL on the web* by James Long (August 12, 2021)](https://jlongster.com/future-sql-web)\n\n> The biggest problem is when sqlite does a read or write, the API is totally synchronous because it’s based\n> on the C API. Accessing IndexedDB is always async, so how do we get around that?\n>\n> We spawn a worker process and give it a SharedArrayBuffer and then use the\n> [`Atomics`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics) API\n> to communicate via the buffer. For example, our backend writes a read request into the shared buffer, and\n> the worker reads it, performs the read async, and then writes the result back.\n>\n> I wrote a small [channel\n> abstraction](https://github.com/jlongster/absurd-sql/blob/master/src/indexeddb/shared-channel.js) to send\n> different types of data across a SharedArrayBuffer.\n>\n> The real magic is the\n> [`Atomics.wait`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/wait)\n> API. It’s a beautiful thing. When you call it, it completely blocks JS until the condition is met. You use\n> it to wait on some data in the SharedArrayBuffer, and this is what enables us to turn the async read/write\n> into a sync one. The backend calls it to wait on the result from the worker and blocks until it’s\n> done.—[*A future for SQL on the web* by James Long (August 12,\n> 2021)](https://jlongster.com/future-sql-web)\n\n\n\n\n###\n\n\n\n\n\n\n'use strict'\n\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'DPAN/TESTS/BASIC'\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\ninfo                      = CND.get_logger 'info',      badge\nurge                      = CND.get_logger 'urge',      badge\nhelp                      = CND.get_logger 'help',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\necho                      = CND.echo.bind CND\n#...........................................................................................................\ndefer                     = setImmediate\nafter                     = ( dts, f ) -> setTimeout  f, dts * 1000\n{ isMainThread\n  Worker\n  workerData            } = require 'worker_threads'\n\n\ndemo_A = ->\n  release = ( typed_array, index, value ) ->\n    ( require 'fs' ).readFile __filename, ( error, data ) ->\n      throw error if error?\n      urge '^898^', \"read #{data.length} bytes\"\n      urge '^565-1^', typed_array[ index ]\n      debug '^477-1^', Atomics.store  typed_array, index, value + 1\n      debug '^477-2^', Atomics.notify typed_array, index, Infinity\n\n  lock = ->\n    index       = 0\n    value       = 0\n    timeout     = 1000\n    sab         = new SharedArrayBuffer 1024\n    typed_array = new Int32Array sab\n    typed_array[ index ] = value # + 1\n    urge '^565-2^', typed_array[ index ]\n    release typed_array, index, value\n    debug '^477-3^', Atomics.wait typed_array, index, value #, timeout\n    urge '^565-3^', typed_array[ index ]\n  lock()\n  # await lock()\n\ndemo_B = ->\n  debug '^447-1^', 'isMainThread', isMainThread\n  worker_count = 3\n  if isMainThread\n    # main thread, create shared memory to share between threads\n    debug '^447^', 'isMainThread'\n    shared_ram = new SharedArrayBuffer Int32Array.BYTES_PER_ELEMENT\n    process.on 'exit', () =>\n      # print final counter\n      result = new Int32Array shared_ram\n      urge '^778^', result\n      urge '^778^', result[0] # expected 5 * 500,000 = 2,500,000\n      return null\n    workers = []\n    for _ in [ 1 .. worker_count ]\n      worker = new Worker __filename, { workerData: shared_ram }\n      debug ( k for k of worker )\n  else\n    shared_data = new Int32Array workerData\n    for i in [ 0 ... 3 ]\n      # debug '^445^', shared_data\n      debug '^445^', shared_data[ 0 ]++\n  return null\n\n\n############################################################################################################\nif module is require.main then do =>\n  demo_A()\n  # await demo_B()\n\n"
  ]
}