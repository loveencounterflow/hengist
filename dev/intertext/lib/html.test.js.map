{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/html.test.coffee"
  ],
  "names": [],
  "mappings": "AACA;EAAA;AAAA,MAAA,GAAA,EAAA,sBAAA,EAAA,KAAA,EAAA,KAAA,EAAA,KAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,OAAA;;;EAGA,GAAA,GAA4B,OAAA,CAAQ,KAAR;;EAC5B,GAAA,GAA4B,GAAG,CAAC;;EAChC,KAAA,GAA4B;;EAC5B,GAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,OAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,OAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,SAAf,EAA4B,KAA5B;;EAC5B,KAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,OAAf,EAA4B,KAA5B;;EAC5B,KAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,OAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,IAAI,CAAC,IAAT,CAAc,GAAd;;EAC5B,CAAA,CAAE,EAAF,CAAA,GAA4B,GAA5B,EAfA;;;EAiBA,IAAA,GAA4B,OAAA,CAAQ,UAAR,EAjB5B;;;EAoBA,sBAAA,GAAyB,QAAA,CAAE,eAAF,EAAmB,SAAS,KAA5B,CAAA;AACzB,QAAA,CAAA,EAAA,MAAA,EAAA,CAAA,EAAA,OAAA,EAAA,GAAA,EAAA,MAAA,EAAA,CAAA,EAAA;IAAE,OAAA,GAAU,mGAAZ;;IAOE,CAAA,GAAI,CAAA;AACJ;IAAA,KAAA,QAAA;OAAI,CAAE,MAAF;MACF,KAAA,WAAA;;QACE,IAAY,CAAM,SAAN,CAAA,IAAc,CAAE,CAAA,KAAK,EAAP,CAA1B;AAAA,mBAAA;;QACA,IAAG,CAAA,KAAK,OAAR;UACE,mBAAE,CAAC,CAAC,QAAF,CAAC,CAAC,QAAS,EAAb,CAAiB,CAAC,IAAlB,CAAuB,CAAvB,EADF;SAAA,MAAA;UAGE,IAAG,uBAAH;YACE,MAAM,IAAI,KAAJ,CAAU,CAAA,0EAAA,CAAA,CAA6E,GAAA,CAAI,CAAJ,CAA7E,CAAA,EAAA,CAAA,CAAuF,GAAA,CAAI,MAAJ,CAAvF,CAAA,EAAA,CAAA,CAAsG,GAAA,CAAI,CAAJ,CAAtG,CAAA,CAAV,EADR;;UAEA,CAAC,CAAE,CAAF,CAAD,GAAS,EALX;;MAFF;IADF;IASA,IAAG,MAAA,IAAe,gBAAlB;MACE,MAAM,IAAI,KAAJ,CAAU,CAAA,0EAAA,CAAA,CAA6E,GAAA,CAAI,eAAJ,CAA7E,CAAA,CAAV,EADR;;AAEA,WAAO;EApBgB,EApBzB;;;;;EA8CA,IAAC,CAAE,4BAAF,CAAD,GAAoC,QAAA,CAAE,CAAF,EAAK,IAAL,CAAA;wCAElC;EAFkC,EA9CpC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAobA,IAAG,MAAA,KAAU,OAAO,CAAC,IAArB;IAAkC,CAAA,CAAA,CAAA,GAAA,EAAA;aAChC,IAAA,CAAK,IAAL;IADgC,CAAA,IAAlC;;AApbA",
  "sourcesContent": [
    "\n'use strict'\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'INTERTEXT/TESTS/HTML'\nlog                       = CND.get_logger 'plain',     badge\ninfo                      = CND.get_logger 'info',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\nalert                     = CND.get_logger 'alert',     badge\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\nhelp                      = CND.get_logger 'help',      badge\nurge                      = CND.get_logger 'urge',      badge\necho                      = CND.echo.bind CND\n{ jr, }                   = CND\n#...........................................................................................................\ntest                      = require 'guy-test'\n\n#-----------------------------------------------------------------------------------------------------------\n_parse_compact_tagname = ( compact_tagname, strict = false ) ->\n  pattern = ///\n    (?<prefix>[^\\s.:#]+(?=:)) |\n    (?<id>(?<=#)[^\\s.:#]+) |\n    (?<class>(?<=\\.)[^\\s.:#]+) |\n    (?<name>[^\\s.:#]+)\n    ///ug\n  # pattern = /(?<prefix>[^\\s.:#]+(?=:))|(?<id>(?<=#)[^\\s.:#]+)|(?<class>(?<=\\.)[^\\s.:#]+)|(?<name>[^\\s.:#]+)/ug\n  R = {}\n  for { groups, } from compact_tagname.matchAll pattern\n    for k, v of groups\n      continue if ( not v? ) or ( v is '' )\n      if k is 'class'\n        ( R.class ?= [] ).push v\n      else\n        if ( target = R[ k ] )?\n          throw new Error \"^paragate/htmlish/_parse_compact_tagname@5584^ found duplicate values for #{rpr k}: #{rpr target}, #{rpr v}\"\n        R[ k ] = v\n  if strict and not R.name?\n    throw new Error \"^paragate/htmlish/_parse_compact_tagname@1^ illegal compact tag syntax in #{rpr compact_tagname}\"\n  return R\n\n\n#===========================================================================================================\n# TESTS\n#-----------------------------------------------------------------------------------------------------------\n@[ \"HTML parse compact tagname\" ] = ( T, done ) ->\n  #.........................................................................................................\n  done?()\n\n#   INTERTEXT \t\t\t\t\t\t\t\t= require '../../../apps/intertext'\n#   { isa\n#     validate\n#     type_of }               = INTERTEXT.types.export()\n#   probes_and_matchers = [\n#     [ \"\",           true,   null, ]\n#     [ \"\\\"\",         true,   null, ]\n#     [ \"'\",          true,   null, ]\n#     [ \"<\",          true,   null, ]\n#     [ \"<>\",         true,   null, ]\n#     [ \"foo\",        false,  null, ]\n#     [ \"foo bar\",    true,   null, ]\n#     [ \"foo\\nbar\",   true,   null, ]\n#     ]\n#   for [ probe, matcher, error, ] in probes_and_matchers\n#     await T.perform probe, matcher, error, -> new Promise ( resolve ) ->\n#       must_quote = not isa.intertext_html_naked_attribute_value probe\n#       resolve must_quote\n#   #.........................................................................................................\n#   done()\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"___TMP_NOT_USED_DATOM.HTML._as_attribute_literal\" ] = ( T, done ) ->\n#   INTERTEXT \t\t\t\t\t\t\t\t= require '../../../apps/intertext'\n#   { HTML, }                 = INTERTEXT\n#   probes_and_matchers = [\n#     [ \"\",           \"''\",                       null, ]\n#     [ '\"',          '\\'\"\\'',                    null, ]\n#     [ \"'\",          \"'&#39;'\",                  null, ]\n#     [ \"<\",          \"'&lt;'\",                   null, ]\n#     [ \"<>\",         \"'&lt;&gt;'\",               null, ]\n#     [ \"foo\",        \"foo\",                      null, ]\n#     [ \"foo bar\",    \"'foo bar'\",                null, ]\n#     [ \"foo\\nbar\",   \"'foo&#10;bar'\",            null, ]\n#     [ \"'<>'\",       \"'&#39;&lt;&gt;&#39;'\",     null, ]\n#     ]\n#   for [ probe, matcher, error, ] in probes_and_matchers\n#     await T.perform probe, matcher, error, -> new Promise ( resolve ) ->\n#       resolve HTML._as_attribute_literal probe\n#   #.........................................................................................................\n#   done()\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"___TMP_NOT_USED_isa.intertext_html_tagname (1)\" ] = ( T, done ) ->\n#   INTERTEXT \t\t\t\t\t\t\t\t= require '../../../apps/intertext'\n#   { isa\n#     validate\n#     type_of }               = INTERTEXT.types.export()\n#   probes_and_matchers = [\n#     [ \"\",             false,  null, ]\n#     [ \"\\\"\",           false,  null, ]\n#     [ \"'\",            false,  null, ]\n#     [ \"<\",            false,  null, ]\n#     [ \"<>\",           false,  null, ]\n#     [ \"foo bar\",      false,  null, ]\n#     [ \"foo\\nbar\",     false,  null, ]\n#     [ \"foo\",          true,   null, ]\n#     [ \"此は何ですか\", true,   null, ]\n#     ]\n#   for [ probe, matcher, error, ] in probes_and_matchers\n#     await T.perform probe, matcher, error, -> new Promise ( resolve ) ->\n#       resolve isa.intertext_html_tagname probe\n#   #.........................................................................................................\n#   done()\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"___TMP_NOT_USED_isa.intertext_html_tagname (2)\" ] = ( T, done ) ->\n#   INTERTEXT \t\t\t\t\t\t\t\t= require '../../../apps/intertext'\n#   { isa\n#     validate\n#     type_of }               = INTERTEXT.types.export()\n#   probes = \"\"\"a abbr acronym address applet area article aside audio b base basefont bdi bdo bgsound big\n#   blink blockquote body br button canvas caption center cite code col colgroup command datalist dd del\n#   details dfn dialog dir div dl dt em embed fieldset figcaption figure font footer form frame frameset h1 h2\n#   h3 h4 h5 h6 head header hgroup hr html i iframe img input ins isindex kbd keygen label legend li link\n#   listing main map mark marquee menu meta meter multicol nav nextid nobr noembed noframes noscript object ol\n#   optgroup option output p param plaintext pre progress q rb rp rt ruby s samp script section select small\n#   source spacer span strike strong sub summary sup table tbody td textarea tfoot th thead time title tr\n#   track tt u ul video wbr xmp\n#   foo:bar foo-bar Foo-bar\n#   \"\"\".split /\\s+/\n#   for probe in probes\n#     await T.perform probe, true, null, -> new Promise ( resolve ) ->\n#       resolve isa.intertext_html_tagname probe\n#   #.........................................................................................................\n#   done()\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"___TMP_NOT_USED_HTML.html_from_datoms (singular tags)\" ] = ( T, done ) ->\n#   DATOM                     = new ( require 'datom' ).Datom { dirty: false, }\n#   { new_datom\n#     lets\n#     select }                = DATOM.export()\n#   INTERTEXT \t\t\t\t\t\t\t\t= require '../../../apps/intertext'\n#   { HTML, }                 = INTERTEXT\n#   probes_and_matchers = [\n#     [ [ '^foo', ],                                    \"<foo></foo>\",                                       ]\n#     [ [ '^foo', { height: 42,               }, ],     \"<foo height=42></foo>\",                             ]\n#     [ [ '^foo', { class: 'plain',           }, ],     \"<foo class=plain></foo>\",                           ]\n#     [ [ '^foo', { class: 'plain hilite',    }, ],     \"<foo class='plain hilite'></foo>\",                  ]\n#     [ [ '^foo', { editable: true,           }, ],     \"<foo editable></foo>\",                              ]\n#     [ [ '^foo', { empty: '',                }, ],     \"<foo empty=''></foo>\",                              ]\n#     [ [ '^foo', { specials: '<\\n\\'\"&>',     }, ],     \"<foo specials='&lt;&#10;&#39;\\\"&amp;&gt;'></foo>\",  ]\n#     [ [ '^something', { one: 1, two: 2,     }, ],     \"<something one=1 two=2></something>\",               ]\n#     [ [ '^something', { z: 'Z', a: 'A',     }, ],     \"<something a=A z=Z></something>\",                   ]\n#     ]\n#   for [ probe, matcher, error, ] in probes_and_matchers\n#     await T.perform probe, matcher, error, -> new Promise ( resolve ) ->\n#       d = new_datom probe...\n#       resolve HTML.html_from_datoms d\n#   #.........................................................................................................\n#   done()\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"___TMP_NOT_USED_HTML.html_from_datoms (closing tags)\" ] = ( T, done ) ->\n#   DATOM                     = new ( require 'datom' ).Datom { dirty: false, }\n#   { new_datom\n#     lets\n#     select }                = DATOM.export()\n#   INTERTEXT \t\t\t\t\t\t\t\t= require '../../../apps/intertext'\n#   { HTML, }                 = INTERTEXT\n#   probes_and_matchers = [\n#     [ [ '>foo', ],                                    \"</foo>\",           ]\n#     [ [ '>foo', { height: 42,               }, ],     \"</foo>\",           ]\n#     [ [ '>foo', { class: 'plain',           }, ],     \"</foo>\",           ]\n#     [ [ '>foo', { class: 'plain hilite',    }, ],     \"</foo>\",           ]\n#     [ [ '>foo', { editable: true,           }, ],     \"</foo>\",           ]\n#     [ [ '>foo', { empty: '',                }, ],     \"</foo>\",           ]\n#     [ [ '>foo', { specials: '<\\n\\'\"&>',     }, ],     \"</foo>\",           ]\n#     [ [ '>something', { one: 1, two: 2,     }, ],     \"</something>\",     ]\n#     [ [ '>something', { z: 'Z', a: 'A',     }, ],     \"</something>\",     ]\n#     ]\n#   for [ probe, matcher, error, ] in probes_and_matchers\n#     await T.perform probe, matcher, error, -> new Promise ( resolve ) ->\n#       d = new_datom probe...\n#       resolve HTML.html_from_datoms d\n#   #.........................................................................................................\n#   done()\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"___TMP_NOT_USED_HTML.html_from_datoms (opening tags)\" ] = ( T, done ) ->\n#   DATOM                     = new ( require 'datom' ).Datom { dirty: false, }\n#   { new_datom\n#     lets\n#     select }                = DATOM.export()\n#   INTERTEXT \t\t\t\t\t\t\t\t= require '../../../apps/intertext'\n#   { HTML, }                 = INTERTEXT\n#   probes_and_matchers = [\n#     [ [ '<foo', ],                                    \"<foo>\",                                        ]\n#     [ [ '<foo', { height: 42,               }, ],     \"<foo height=42>\",                              ]\n#     [ [ '<foo', { class: 'plain',           }, ],     \"<foo class=plain>\",                            ]\n#     [ [ '<foo', { class: 'plain hilite',    }, ],     \"<foo class='plain hilite'>\",                   ]\n#     [ [ '<foo', { editable: true,           }, ],     \"<foo editable>\",                               ]\n#     [ [ '<foo', { empty: '',                }, ],     \"<foo empty=''>\",                               ]\n#     [ [ '<foo', { specials: '<\\n\\'\"&>',     }, ],     \"<foo specials='&lt;&#10;&#39;\\\"&amp;&gt;'>\",   ]\n#     [ [ '<something', { one: 1, two: 2,     }, ],     \"<something one=1 two=2>\",                      ]\n#     [ [ '<something', { z: 'Z', a: 'A',     }, ],     \"<something a=A z=Z>\",                          ]\n#     ]\n#   for [ probe, matcher, error, ] in probes_and_matchers\n#     await T.perform probe, matcher, error, -> new Promise ( resolve ) ->\n#       d = new_datom probe...\n#       resolve HTML.html_from_datoms d\n#   #.........................................................................................................\n#   done()\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"___TMP_NOT_USED_HTML.html_from_datoms (texts)\" ] = ( T, done ) ->\n#   DATOM                     = new ( require 'datom' ).Datom { dirty: false, }\n#   { new_datom\n#     lets\n#     select }                = DATOM.export()\n#   INTERTEXT \t\t\t\t\t\t\t\t= require '../../../apps/intertext'\n#   { HTML, }                 = INTERTEXT\n#   probes_and_matchers = [\n#     [ [ '^text', ],                                    \"\",                            ]\n#     [ [ '^text', { height: 42,               }, ],     \"\",                            ]\n#     [ [ '^text', { text: '<me & you>\\n',     }, ],     \"&lt;me &amp; you&gt;\\n\",      ]\n#     [ [ '<text', { z: 'Z', a: 'A',           }, ],     \"<text a=A z=Z>\",              ]\n#     ]\n#   for [ probe, matcher, error, ] in probes_and_matchers\n#     await T.perform probe, matcher, error, -> new Promise ( resolve ) ->\n#       d = new_datom probe...\n#       resolve HTML.html_from_datoms d\n#   #.........................................................................................................\n#   done()\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"___TMP_NOT_USED_HTML.html_from_datoms (opening tags w/ $value)\" ] = ( T, done ) ->\n#   DATOM                     = new ( require 'datom' ).Datom { dirty: false, }\n#   { new_datom\n#     lets\n#     select }                = DATOM.export()\n#   INTERTEXT \t\t\t\t\t\t\t\t= require '../../../apps/intertext'\n#   { HTML, }                 = INTERTEXT\n#   probes_and_matchers = [\n#     [ [ '<foo', ],                                    \"<foo>\",                                        ]\n#     [ [ '<foo', { ignored: 'xxx', $value: { height: 42,              }, }, ], \"<foo height=42>\",                              ]\n#     [ [ '<foo', { ignored: 'xxx', $value: { class: 'plain',          }, }, ], \"<foo class=plain>\",                            ]\n#     [ [ '<foo', { ignored: 'xxx', $value: { class: 'plain hilite',   }, }, ], \"<foo class='plain hilite'>\",                   ]\n#     [ [ '<foo', { ignored: 'xxx', $value: { editable: true,          }, }, ], \"<foo editable>\",                               ]\n#     [ [ '<foo', { ignored: 'xxx', $value: { empty: '',               }, }, ], \"<foo empty=''>\",                               ]\n#     [ [ '<foo', { ignored: 'xxx', $value: { specials: '<\\n\\'\"&>',    }, }, ], \"<foo specials='&lt;&#10;&#39;\\\"&amp;&gt;'>\",   ]\n#     [ [ '<something', { ignored: 'xxx', $value: { one: 1, two: 2,    }, }, ], \"<something one=1 two=2>\",                      ]\n#     [ [ '<something', { ignored: 'xxx', $value: { z: 'Z', a: 'A',    }, }, ], \"<something a=A z=Z>\",                          ]\n#     ]\n#   for [ probe, matcher, error, ] in probes_and_matchers\n#     await T.perform probe, matcher, error, -> new Promise ( resolve ) ->\n#       d = new_datom probe...\n#       resolve HTML.html_from_datoms d\n#   #.........................................................................................................\n#   done()\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"___TMP_NOT_USED_HTML.html_from_datoms (system tags)\" ] = ( T, done ) ->\n#   DATOM                     = new ( require 'datom' ).Datom { dirty: false, }\n#   { new_datom\n#     lets\n#     select }                = DATOM.export()\n#   INTERTEXT \t\t\t\t\t\t\t\t= require '../../../apps/intertext'\n#   { HTML, }                 = INTERTEXT\n#   probes_and_matchers = [\n#     [[\"~foo\"],\"<x-sys x-key=foo><x-sys-key>foo</x-sys-key></x-sys>\",null]\n#     [[\"~foo\",{\"height\":42}],\"<x-sys x-key=foo height=42><x-sys-key>foo</x-sys-key></x-sys>\",null]\n#     [[\"[foo\",{\"class\":\"plain\"}],\"<x-sys x-key=foo class=plain><x-sys-key>foo</x-sys-key>\",null]\n#     [[\"[foo\",{\"class\":\"plain hilite\"}],\"<x-sys x-key=foo class='plain hilite'><x-sys-key>foo</x-sys-key>\",null]\n#     [[\"]foo\",{\"editable\":true}],\"</x-sys>\",null]\n#     [[\"]foo\",{\"empty\":\"\"}],\"</x-sys>\",null]\n#     [[\"~foo\",{\"specials\":\"<\\n'\\\"&>\"}],\"<x-sys x-key=foo specials='&lt;&#10;&#39;\\\"&amp;&gt;'><x-sys-key>foo</x-sys-key></x-sys>\",null]\n#     [[\"~something\",{\"one\":1,\"two\":2}],\"<x-sys x-key=something one=1 two=2><x-sys-key>something</x-sys-key></x-sys>\",null]\n#     [[\"~something\",{\"z\":\"Z\",\"a\":\"A\"}],\"<x-sys x-key=something a=A z=Z><x-sys-key>something</x-sys-key></x-sys>\",null]\n#     ]\n#   for [ probe, matcher, error, ] in probes_and_matchers\n#     await T.perform probe, matcher, error, -> new Promise ( resolve ) ->\n#       d = new_datom probe...\n#       resolve HTML.html_from_datoms d\n#   #.........................................................................................................\n#   done()\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"___TMP_NOT_USED_HTML.html_from_datoms (raw pseudo-tag)\" ] = ( T, done ) ->\n#   DATOM                     = new ( require 'datom' ).Datom { dirty: false, }\n#   { new_datom\n#     lets\n#     select }                = DATOM.export()\n#   INTERTEXT \t\t\t\t\t\t\t\t= require '../../../apps/intertext'\n#   { HTML, }                 = INTERTEXT\n#   probes_and_matchers = [\n#     [ [ '^raw', ],                                    \"\",                                       ]\n#     [ [ '^raw', { height: 42,               }, ],     \"\",                                       ]\n#     [ [ '^raw', { text: '<\\n\\'\"&>',           }, ],   '<\\n\\'\"&>',                               ]\n#     ]\n#   for [ probe, matcher, error, ] in probes_and_matchers\n#     await T.perform probe, matcher, error, -> new Promise ( resolve ) ->\n#       d = new_datom probe...\n#       resolve HTML.html_from_datoms d\n#   #.........................................................................................................\n#   done()\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"___TMP_NOT_USED_HTML.html_from_datoms (doctype)\" ] = ( T, done ) ->\n#   DATOM                     = new ( require 'datom' ).Datom { dirty: false, }\n#   { new_datom\n#     lets\n#     select }                = DATOM.export()\n#   INTERTEXT \t\t\t\t\t\t\t\t= require '../../../apps/intertext'\n#   { HTML, }                 = INTERTEXT\n#   probes_and_matchers = [\n#     [ [ '^doctype', ],                  \"<!DOCTYPE html>\",        ]\n#     [ [ '^doctype', { height: 42, }, ], \"<!DOCTYPE html>\",        ]\n#     [ [ '^doctype', \"obvious\", ],       \"<!DOCTYPE obvious>\",     ]\n#     ]\n#   for [ probe, matcher, error, ] in probes_and_matchers\n#     await T.perform probe, matcher, error, -> new Promise ( resolve ) ->\n#       d = new_datom probe...\n#       resolve ( HTML.html_from_datoms d ).trim()\n#   #.........................................................................................................\n#   done()\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"___TMP_NOT_USED_HTML.html_from_datoms (1)\" ] = ( T, done ) ->\n#   INTERTEXT \t\t\t\t\t\t\t\t= require '../../../apps/intertext'\n#   { html_from_datoms\n#     tag }                 = INTERTEXT.HTML.export()\n#   #.........................................................................................................\n#   probes_and_matchers = [\n#     [[\"div\"],\"<div></div>\",null]\n#     [[\"div#x32\"],\"<div id=x32></div>\",null]\n#     [[\"div.foo\"],\"<div class=foo></div>\",null]\n#     [[\"div#x32.foo\"],\"<div class=foo id=x32></div>\",null]\n#     [[\"div#x32\",{\"alt\":\"nice guy\"}],\"<div alt='nice guy' id=x32></div>\",null]\n#     [[\"div#x32\",{\"alt\":\"nice guy\"},\" a > b & b > c => a > c\"],\"<div alt='nice guy' id=x32> a &gt; b &amp; b &gt; c =&gt; a &gt; c</div>\",null]\n#     [[\"foo-bar\"],\"<foo-bar></foo-bar>\",null]\n#     [[\"foo-bar#c55\"],\"<foo-bar id=c55></foo-bar>\",null]\n#     [[\"foo-bar.blah.beep\"],\"<foo-bar class='blah beep'></foo-bar>\",null]\n#     [[\"foo-bar#c55.blah.beep\"],\"<foo-bar class='blah beep' id=c55></foo-bar>\",null]\n#     [[\"#c55\"],null,\"not a valid intertext_html_tagname\"]\n#     [[\".blah.beep\"],null,\"not a valid intertext_html_tagname\"]\n#     [[\"...#\"],null,\"illegal compact tag syntax\"]\n#     ]\n#   for [ probe, matcher, error, ] in probes_and_matchers\n#     await T.perform probe, matcher, error, -> new Promise ( resolve ) ->\n#       # urge html_from_datoms tag probe...\n#       resolve html_from_datoms tag probe...\n#   #.........................................................................................................\n#   done()\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"___TMP_NOT_USED_HTML.html_from_datoms (2)\" ] = ( T, done ) ->\n#   INTERTEXT \t\t\t\t\t\t\t\t= require '../../../apps/intertext'\n#   { html_from_datoms\n#     tag }                 = INTERTEXT.HTML.export()\n#   #.........................................................................................................\n#   urge ds = tag 'article#c2', { editable: true, }, ( tag 'h1', \"A truly curious Coincidence\" )\n#   T.eq ds, [\n#     { '$key': '<article', id: 'c2', editable: true },\n#     { '$key': '<h1' },\n#     { '$key': '^text', text: 'A truly curious Coincidence' },\n#     { '$key': '>h1' }\n#     { '$key': '>article' }\n#     ]\n#   #.........................................................................................................\n#   done()\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"___TMP_NOT_USED_HTML.html_from_datoms (3)\" ] = ( T, done ) ->\n#   INTERTEXT \t\t\t\t\t\t\t\t= require '../../../apps/intertext'\n#   { html_from_datoms\n#     tag }                 = INTERTEXT.HTML.export()\n#   #.........................................................................................................\n#   urge ds = tag 'article#c2', { editable: true, },\n#     tag 'h1', \"A truly curious Coincidence\"\n#     tag 'p.noindent', ( tag 'em', \"Seriously,\" ), \" he said, \", ( tag 'em', \"we'd better start cooking now.\" )\n#   #.........................................................................................................\n#   whisper jr html_from_datoms ds\n#   T.eq ( html_from_datoms ds ), \"<article editable id=c2><h1>A truly curious Coincidence</h1><p class=noindent><em>Seriously,</em> he said, <em>we'd better start cooking now.</em></p></article>\"\n#   T.eq ds, [\n#     { '$key': '<article', id: 'c2', editable: true },\n#     { '$key': '<h1' },\n#     { '$key': '^text', text: 'A truly curious Coincidence' },\n#     { '$key': '>h1' },\n#     { '$key': '<p', class: 'noindent' },\n#     { '$key': '<em' },\n#     { '$key': '^text', text: 'Seriously,' },\n#     { '$key': '>em' },\n#     { '$key': '^text', text: ' he said, ' },\n#     { '$key': '<em' },\n#     { '$key': '^text', text: \"we'd better start cooking now.\" },\n#     { '$key': '>em' },\n#     { '$key': '>p' },\n#     { '$key': '>article' }\n#     ]\n#   #.........................................................................................................\n#   done()\n#   return null\n\n# # #-----------------------------------------------------------------------------------------------------------\n# # @[ \"HTML.datoms_as_nlhtml (1)\" ] = ( T, done ) ->\n#   INTERTEXT \t\t\t\t\t\t\t\t= require '../../../apps/intertext'\n# #   { datoms_as_nlhtml\n# #     datoms_from_html }        = INTERTEXT.HTML.export()\n# #   #.........................................................................................................\n# #   urge jr ds = datoms_from_html \"\"\"\n# #     <h1>A Star is Born</h1><p class=noindent>Stars are born when hydrogen amasses.</p><p>When they are <em>big</em> enough, nuclear fusion starts.</p>\n# #     \"\"\"\n# #   #.........................................................................................................\n# #   help datoms_as_nlhtml ds\n# #   done()\n# #   return null\n\n\n\n############################################################################################################\nif module is require.main then do => # await do =>\n  test @\n"
  ]
}