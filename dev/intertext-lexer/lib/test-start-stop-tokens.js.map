{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/test-start-stop-tokens.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n'use strict'\n\n\n############################################################################################################\nGUY                       = require 'guy'\n{ alert\n  debug\n  help\n  info\n  plain\n  praise\n  urge\n  warn\n  whisper }               = GUY.trm.get_loggers 'interlex/test-start-stop-tokens'\n{ rpr\n  inspect\n  echo\n  log     }               = GUY.trm\n#...........................................................................................................\ntest                      = require '../../../apps/guy-test'\n# PATH                      = require 'path'\n# FS                        = require 'fs'\ntypes                     = new ( require 'intertype' ).Intertype\n{ isa\n  equals\n  type_of\n  validate\n  validate_list_of }      = types.export()\n{ DATOM }                 = require '../../../apps/datom'\n{ new_datom\n  lets\n  stamp     }             = DATOM\nH                         = require './helpers'\n\n\n\n#===========================================================================================================\n# START AND STOP TOKENS\n#-----------------------------------------------------------------------------------------------------------\n@first_and_last = ( T, done ) ->\n  { Interlex\n    compose\n    tools   } = require '../../../apps/intertext-lexer'\n  #.........................................................................................................\n  new_lexer = ( cfg ) ->\n    lexer   = new Interlex cfg\n    #.........................................................................................................\n    do =>\n      mode = 'plain'\n      lexer.add_lexeme { mode, lxid: 'line',    pattern: /line/u, }\n      lexer.add_lexeme { mode, lxid: 'lnr',     pattern: /\\d/u, }\n      lexer.add_lexeme { mode, lxid: 'nl',      pattern: /\\n/u, }\n    #.........................................................................................................\n    return lexer\n  #.........................................................................................................\n  probes_and_matchers = [\n    [ [ 'line1\\nline2', { split: 'lines',                               } ], \"plain:line'line'|plain:lnr'1'|plain:line'line'|plain:lnr'2'\", null ]\n    [ [ 'line1\\nline2', { split: false,                                 } ], \"plain:line'line'|plain:lnr'1'|plain:nl'\\\\n'|plain:line'line'|plain:lnr'2'\", null ]\n    [ [ 'line1\\nline2', { split: 'lines',                 last: 'LAST', } ], \"plain:line'line'|plain:lnr'1'|plain:line'line'|plain:lnr'2'|LAST\", null ]\n    [ [ 'line1\\nline2', { split: false,                   last: 'LAST'  } ], \"plain:line'line'|plain:lnr'1'|plain:nl'\\\\n'|plain:line'line'|plain:lnr'2'|LAST\", null ]\n    [ [ 'line1\\nline2', { split: 'lines', first: 'FIRST',               } ], \"FIRST|plain:line'line'|plain:lnr'1'|plain:line'line'|plain:lnr'2'\", null ]\n    [ [ 'line1\\nline2', { split: false,   first: 'FIRST',               } ], \"FIRST|plain:line'line'|plain:lnr'1'|plain:nl'\\\\n'|plain:line'line'|plain:lnr'2'\", null ]\n    [ [ 'line1\\nline2', { split: 'lines', first: 'FIRST', last: 'LAST', } ], \"FIRST|plain:line'line'|plain:lnr'1'|plain:line'line'|plain:lnr'2'|LAST\", null ]\n    [ [ 'line1\\nline2', { split: false,   first: 'FIRST', last: 'LAST'  } ], \"FIRST|plain:line'line'|plain:lnr'1'|plain:nl'\\\\n'|plain:line'line'|plain:lnr'2'|LAST\", null ]\n    ]\n  #.........................................................................................................\n  for [ probe, matcher, error, ] in probes_and_matchers\n    await T.perform probe, matcher, error, -> return new Promise ( resolve, reject ) ->\n      # H.show_lexer_as_table 'new_syntax_for_modes', lexer; process.exit 111\n      [ value\n        cfg     ] = probe\n      result      = []\n      tokens      = []\n      lexer       = new_lexer cfg\n      lexer.set_position cfg if cfg?\n      for d from lexer.walk { value, cfg..., }\n        if isa.text d\n          result.push d\n        else\n          result.push \"#{d.$key}#{rpr d.value}\"\n        # result.push GUY.props.pick_with_fallback d, null, 'value', 'lnr1', 'x1', 'lnr2', 'x2'\n        tokens.push d\n      result = result.join '|'\n      # H.tabulate \"#{rpr probe}\", tokens\n      # echo rpr result\n      resolve result\n  #.........................................................................................................\n  done?()\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\n@start_and_end_of_line = ( T, done ) ->\n  { Interlex\n    compose\n    tools   } = require '../../../apps/intertext-lexer'\n  #.........................................................................................................\n  new_lexer = ( cfg ) ->\n    lexer   = new Interlex cfg\n    #.........................................................................................................\n    do =>\n      mode = 'plain'\n      lexer.add_lexeme { mode, lxid: 'line',    pattern: /line/u, }\n      lexer.add_lexeme { mode, lxid: 'lnr',     pattern: /\\d/u, }\n      lexer.add_lexeme { mode, lxid: 'nl',      pattern: /\\n/u, }\n    #.........................................................................................................\n    return lexer\n  #.........................................................................................................\n  probes_and_matchers = [\n    [ [ 'line1\\nline2', { split: 'lines',                                           } ], \"plain:line'line'|plain:lnr'1'|plain:line'line'|plain:lnr'2'\", null ]\n    [ [ 'line1\\nline2', { split: false,                                             } ], \"plain:line'line'|plain:lnr'1'|plain:nl'\\\\n'|plain:line'line'|plain:lnr'2'\", null ]\n    [ [ 'line1\\nline2', { split: 'lines',                       end_of_line: 'EOL', } ], \"plain:line'line'|plain:lnr'1'|EOL|plain:line'line'|plain:lnr'2'|EOL\", null ]\n    [ [ 'line1\\nline2', { split: false,                         end_of_line: 'EOL'  } ], \"plain:line'line'|plain:lnr'1'|plain:nl'\\\\n'|plain:line'line'|plain:lnr'2'\", null ]\n    [ [ 'line1\\nline2', { split: 'lines', start_of_line: 'SOL',                     } ], \"SOL|plain:line'line'|plain:lnr'1'|SOL|plain:line'line'|plain:lnr'2'\", null ]\n    [ [ 'line1\\nline2', { split: false,   start_of_line: 'SOL',                     } ], \"plain:line'line'|plain:lnr'1'|plain:nl'\\\\n'|plain:line'line'|plain:lnr'2'\", null ]\n    [ [ 'line1\\nline2', { split: 'lines', start_of_line: 'SOL', end_of_line: 'EOL', } ], \"SOL|plain:line'line'|plain:lnr'1'|EOL|SOL|plain:line'line'|plain:lnr'2'|EOL\", null ]\n    [ [ 'line1\\nline2', { split: false,   start_of_line: 'SOL', end_of_line: 'EOL'  } ], \"plain:line'line'|plain:lnr'1'|plain:nl'\\\\n'|plain:line'line'|plain:lnr'2'\", null ]\n    ]\n  #.........................................................................................................\n  for [ probe, matcher, error, ] in probes_and_matchers\n    await T.perform probe, matcher, error, -> return new Promise ( resolve, reject ) ->\n      # H.show_lexer_as_table 'new_syntax_for_modes', lexer; process.exit 111\n      [ value\n        cfg     ] = probe\n      result      = []\n      tokens      = []\n      lexer       = new_lexer cfg\n      lexer.set_position cfg if cfg?\n      for d from lexer.walk { value, cfg..., }\n        if isa.text d\n          result.push d\n        else\n          result.push \"#{d.$key}#{rpr d.value}\"\n        # result.push GUY.props.pick_with_fallback d, null, 'value', 'lnr1', 'x1', 'lnr2', 'x2'\n        tokens.push d\n      result = result.join '|'\n      # H.tabulate \"#{rpr probe}\", tokens\n      # echo rpr result\n      resolve result\n  #.........................................................................................................\n  done?()\n  return null\n\n\n\n\n############################################################################################################\nif require.main is module then do =>\n  test @\n"
  ]
}