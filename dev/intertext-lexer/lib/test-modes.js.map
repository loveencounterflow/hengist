{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/test-modes.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n'use strict'\n\n\n############################################################################################################\nGUY                       = require 'guy'\n{ alert\n  debug\n  help\n  info\n  plain\n  praise\n  urge\n  warn\n  whisper }               = GUY.trm.get_loggers 'INTERTEXT-LEXER/TESTS/MODES'\n{ rpr\n  inspect\n  echo\n  log     }               = GUY.trm\n#...........................................................................................................\ntest                      = require '../../../apps/guy-test'\n# PATH                      = require 'path'\n# FS                        = require 'fs'\ntypes                     = new ( require 'intertype' ).Intertype\n{ isa\n  equals\n  type_of\n  validate\n  validate_list_of }      = types.export()\n{ DATOM }                 = require '../../../apps/datom'\n{ new_datom\n  lets\n  stamp     }             = DATOM\nH                         = require './helpers'\n\n\n#-----------------------------------------------------------------------------------------------------------\n@new_syntax_for_in_and_exclusive_jumps_1 = ( T, done ) ->\n  { Interlex\n    compose  }        = require '../../../apps/intertext-lexer'\n  #.........................................................................................................\n  new_lexer = ->\n    lexer   = new Interlex { split: 'lines', }\n    #.........................................................................................................\n    do =>\n      mode = 'plain'\n      lexer.add_lexeme { mode, lxid: 'escchr', jump: null,           pattern: /\\\\(?<chr>.)/u, reserved: '\\\\', }\n      lexer.add_lexeme { mode, lxid: 'dq1',    jump: 'dq1[',         pattern: /(?<!\")\"(?!\")/u, reserved: '\"', }\n      lexer.add_lexeme { mode, lxid: 'nl',     jump: null,           pattern: /$/u, value: '\\n', }\n      lexer.add_catchall_lexeme { mode, lxid: 'text', concat: true, }\n    #.........................................................................................................\n    do =>\n      mode = 'dq1'\n      lexer.add_lexeme { mode, lxid: 'escchr', jump: null,           pattern: /\\\\(?<chr>.)/u, reserved: '\\\\', }\n      lexer.add_lexeme { mode, lxid: 'dq1',    jump: '.]',           pattern: /\"/u, reserved: '\"', }\n      lexer.add_lexeme { mode, lxid: 'nl',     jump: null,           pattern: /$/u, value: '\\n', }\n      lexer.add_catchall_lexeme { mode, lxid: 'text', concat: true, }\n    #.........................................................................................................\n    return lexer\n  #.........................................................................................................\n  probes_and_matchers = [\n    [ 'helo', [ { mk: 'plain:text', value: 'helo' }, { mk: 'plain:nl', value: '\\n' } ], null ]\n    [ 'helo \"world\"', [ { mk: 'plain:text', value: 'helo ' }, { mk: 'plain:dq1', value: '\"' }, { mk: 'dq1:text', value: 'world' }, { mk: 'dq1:dq1', value: '\"' }, { mk: 'plain:nl', value: '\\n' } ], null ]\n    [ 'helo \"everyone\\nout there\"!', [ { mk: 'plain:text', value: 'helo ' }, { mk: 'plain:dq1', value: '\"' }, { mk: 'dq1:text', value: 'everyone' }, { mk: 'dq1:nl', value: '\\n' }, { mk: 'dq1:text', value: 'out there' }, { mk: 'dq1:dq1', value: '\"' }, { mk: 'plain:text', value: '!' }, { mk: 'plain:nl', value: '\\n' } ], null ]\n    ]\n  #.........................................................................................................\n  # for [ probe, matcher, error, ] in probes_and_matchers\n  #     lexer       = new_lexer()\n  #     # H.show_lexer_as_table 'new_syntax_for_modes', lexer; process.exit 111\n  #     result      = []\n  #     for token from lexer.walk probe\n  #       result.push GUY.props.pick_with_fallback token, null, 'mk', 'value'\n  #     result_rpr  = ( d.value for d in result when not d.$stamped ).join ''\n  #     H.tabulate \"#{rpr probe} -> #{rpr result_rpr}\", result # unless result_rpr is matcher\n  for [ probe, matcher, error, ] in probes_and_matchers\n    await T.perform probe, matcher, error, -> return new Promise ( resolve, reject ) ->\n      lexer       = new_lexer()\n      # H.show_lexer_as_table 'new_syntax_for_modes', lexer; process.exit 111\n      result      = []\n      for token from lexer.walk probe\n        result.push GUY.props.pick_with_fallback token, null, 'mk', 'value'\n      result_rpr  = ( d.value for d in result when not d.$stamped ).join ''\n      # H.tabulate \"#{rpr probe} -> #{rpr result_rpr}\", result # unless result_rpr is matcher\n      #.....................................................................................................\n      resolve result\n  #.........................................................................................................\n  done?()\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\n@new_syntax_for_in_and_exclusive_jumps_2 = ( T, done ) ->\n  { Interlex\n    compose  }        = require '../../../apps/intertext-lexer'\n  #.........................................................................................................\n  new_lexer = ->\n    lexer   = new Interlex { split: 'lines', }\n    #.........................................................................................................\n    do =>\n      mode = 'plain'\n      lexer.add_lexeme { mode, lxid: 'escchr', jump: null,           pattern: /\\\\(?<chr>.)/u,  reserved: '\\\\', }\n      lexer.add_lexeme { mode, lxid: 'dq1',    jump: '[dq1',         pattern: /\"/u,            reserved: '\"', }\n      lexer.add_lexeme { mode, lxid: 'nl',     jump: null,           pattern: /$/u, value: '\\n', }\n      lexer.add_catchall_lexeme { mode, lxid: 'text', concat: true, }\n    #.........................................................................................................\n    do =>\n      mode = 'dq1'\n      lexer.add_lexeme { mode, lxid: 'escchr', jump: null,           pattern: /\\\\(?<chr>.)/u, reserved: '\\\\', }\n      lexer.add_lexeme { mode, lxid: 'dq1',    jump: '].',           pattern: /\"/u, reserved: '\"', }\n      lexer.add_lexeme { mode, lxid: 'nl',     jump: null,           pattern: /$/u, value: '\\n', }\n      lexer.add_catchall_lexeme { mode, lxid: 'text', concat: true, }\n    #.........................................................................................................\n    return lexer\n  #.........................................................................................................\n  probes_and_matchers = [\n    [ 'helo', [ { mk: 'plain:text', value: 'helo' }, { mk: 'plain:nl', value: '\\n' } ], null ]\n    [ 'helo \"world\"', [ { mk: 'plain:text', value: 'helo ' }, { mk: 'dq1:dq1', value: '\"' }, { mk: 'dq1:text', value: 'world' }, { mk: 'plain:dq1', value: '\"' }, { mk: 'plain:nl', value: '\\n' } ], null ]\n    [ 'helo \"everyone\\nout there\"!', [ { mk: 'plain:text', value: 'helo ' }, { mk: 'dq1:dq1', value: '\"' }, { mk: 'dq1:text', value: 'everyone' }, { mk: 'dq1:nl', value: '\\n' }, { mk: 'dq1:text', value: 'out there' }, { mk: 'plain:dq1', value: '\"' }, { mk: 'plain:text', value: '!' }, { mk: 'plain:nl', value: '\\n' } ], null ]\n    [ '\"one\"\"two\"', [ { mk: 'dq1:dq1', value: '\"' }, { mk: 'dq1:text', value: 'one' }, { mk: 'plain:dq1', value: '\"' }, { mk: 'dq1:dq1', value: '\"' }, { mk: 'dq1:text', value: 'two' }, { mk: 'plain:dq1', value: '\"' }, { mk: 'plain:nl', value: '\\n' } ], null ]\n    ]\n  #.........................................................................................................\n  for [ probe, matcher, error, ] in probes_and_matchers\n    await T.perform probe, matcher, error, -> return new Promise ( resolve, reject ) ->\n      lexer       = new_lexer()\n      # H.show_lexer_as_table 'new_syntax_for_modes', lexer; process.exit 111\n      result      = []\n      tokens      = []\n      for token from lexer.walk probe\n        tokens.push token\n        result.push GUY.props.pick_with_fallback token, null, 'mk', 'value'\n      result_rpr  = ( d.value for d in result when not d.$stamped ).join ''\n      H.tabulate \"#{rpr probe} -> #{rpr result_rpr}\", tokens\n      #.....................................................................................................\n      resolve result\n  #.........................................................................................................\n  done?()\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\n@new_syntax_for_in_and_exclusive_jumps_3 = ( T, done ) ->\n  { Interlex\n    compose  }        = require '../../../apps/intertext-lexer'\n  #.........................................................................................................\n  new_lexer = ->\n    lexer   = new Interlex { split: 'lines', }\n    #.........................................................................................................\n    do =>\n      mode = 'plain'\n      lexer.add_lexeme { mode, lxid: 'escchr', jump: null,           pattern: /\\\\(?<chr>.)/u,  reserved: '\\\\', }\n      lexer.add_lexeme { mode, lxid: 'dq1',    jump: '[dq1',         pattern: /\"/u,            reserved: '\"', }\n      lexer.add_lexeme { mode, lxid: 'nl',     jump: null,           pattern: /$/u, value: '\\n', }\n      lexer.add_catchall_lexeme { mode, lxid: 'text', concat: true, }\n    #.........................................................................................................\n    do =>\n      mode = 'dq1'\n      lexer.add_lexeme { mode, lxid: 'escchr', jump: null,           pattern: /\\\\(?<chr>.)/u, reserved: '\\\\', }\n      lexer.add_lexeme { mode, lxid: 'dq1',    jump: '.]',           pattern: /\"/u, reserved: '\"', }\n      lexer.add_lexeme { mode, lxid: 'nl',     jump: null,           pattern: /$/u, value: '\\n', }\n      lexer.add_catchall_lexeme { mode, lxid: 'text', concat: true, }\n    #.........................................................................................................\n    return lexer\n  #.........................................................................................................\n  probes_and_matchers = [\n    [ 'helo', [ { mk: 'plain:text', value: 'helo' }, { mk: 'plain:nl', value: '\\n' } ], null ]\n    [ 'helo \"world\"', [ { mk: 'plain:text', value: 'helo ' }, { mk: 'dq1:dq1', value: '\"' }, { mk: 'dq1:text', value: 'world' }, { mk: 'dq1:dq1', value: '\"' }, { mk: 'plain:nl', value: '\\n' } ], null ]\n    [ 'helo \"everyone\\nout there\"!', [ { mk: 'plain:text', value: 'helo ' }, { mk: 'dq1:dq1', value: '\"' }, { mk: 'dq1:text', value: 'everyone' }, { mk: 'dq1:nl', value: '\\n' }, { mk: 'dq1:text', value: 'out there' }, { mk: 'dq1:dq1', value: '\"' }, { mk: 'plain:text', value: '!' }, { mk: 'plain:nl', value: '\\n' } ], null ]\n    [ '\"one\"\"two\"', [ { mk: 'dq1:dq1', value: '\"' }, { mk: 'dq1:text', value: 'one' }, { mk: 'dq1:dq1', value: '\"' }, { mk: 'dq1:dq1', value: '\"' }, { mk: 'dq1:text', value: 'two' }, { mk: 'dq1:dq1', value: '\"' }, { mk: 'plain:nl', value: '\\n' } ], null ]\n    ]\n  #.........................................................................................................\n  for [ probe, matcher, error, ] in probes_and_matchers\n    await T.perform probe, matcher, error, -> return new Promise ( resolve, reject ) ->\n      lexer       = new_lexer()\n      # H.show_lexer_as_table 'new_syntax_for_modes', lexer; process.exit 111\n      result      = []\n      tokens      = []\n      for token from lexer.walk probe\n        tokens.push token\n        result.push GUY.props.pick_with_fallback token, null, 'mk', 'value'\n      result_rpr  = ( d.value for d in result when not d.$stamped ).join ''\n      H.tabulate \"#{rpr probe} -> #{rpr result_rpr}\", tokens\n      #.....................................................................................................\n      resolve result\n  #.........................................................................................................\n  done?()\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\n@singular_jumps = ( T, done ) ->\n  { Interlex\n    compose  }        = require '../../../apps/intertext-lexer'\n  #.........................................................................................................\n  new_lexer = ( cfg = null ) ->\n    lexer   = new Interlex { split: 'lines', cfg..., }\n    #.........................................................................................................\n    do =>\n      mode = 'plain'\n      lexer.add_lexeme { mode, lxid: 'escchr', jump: null,       pattern: /\\\\(?<chr>.)/u,    reserved: '\\\\', }\n      lexer.add_lexeme { mode, lxid: 'dq2',    jump: '[dqstr]',  pattern: /(?<!\")\"\"(?!\")/u,  reserved: '\"', }\n      lexer.add_lexeme { mode, lxid: 'dq1',    jump: '[dqstr',   pattern: /(?<!\")\"(?!\")/u,   reserved: '\"', }\n      lexer.add_lexeme { mode, lxid: 'nl',     jump: null,       pattern: /$/u, value: '\\n', }\n      lexer.add_catchall_lexeme { mode, lxid: 'text', concat: true, }\n    #.........................................................................................................\n    do =>\n      mode = 'dqstr'\n      lexer.add_lexeme { mode, lxid: 'escchr', jump: null,           pattern: /\\\\(?<chr>.)/u, reserved: '\\\\', }\n      lexer.add_lexeme { mode, lxid: 'dq1',    jump: '.]',           pattern: /\"/u, reserved: '\"', }\n      lexer.add_lexeme { mode, lxid: 'nl',     jump: null,           pattern: /$/u, value: '\\n', }\n      lexer.add_catchall_lexeme { mode, lxid: 'text', concat: true, }\n    #.........................................................................................................\n    return lexer\n  #.........................................................................................................\n  probes_and_matchers = [\n    [ 'helo', [ { mk: 'plain:text', value: 'helo', data: null }, { mk: 'plain:nl', value: '\\n', data: null } ], null ]\n    [ 'helo \"world\"', [ { mk: 'plain:text', value: 'helo ', data: null }, { mk: 'dqstr:$border', value: '', data: { prv: 'plain', nxt: 'dqstr' } }, { mk: 'dqstr:dq1', value: '\"', data: null }, { mk: 'dqstr:text', value: 'world', data: null }, { mk: 'dqstr:dq1', value: '\"', data: null }, { mk: 'plain:$border', value: '', data: { prv: 'dqstr', nxt: 'plain' } }, { mk: 'plain:nl', value: '\\n', data: null } ], null ]\n    [ 'abc \"\" xyz', [ { mk: 'plain:text', value: 'abc ', data: null }, { mk: 'plain:$border', value: '', data: { prv: 'plain', nxt: 'dqstr' } }, { mk: 'dqstr:dq2', value: '\"\"', data: null }, { mk: 'plain:$border', value: '', data: { prv: 'dqstr', nxt: 'plain' } }, { mk: 'plain:text', value: ' xyz', data: null }, { mk: 'plain:nl', value: '\\n', data: null } ], null ]\n    ]\n  #.........................................................................................................\n  for [ probe, matcher, error, ] in probes_and_matchers\n    await T.perform probe, matcher, error, -> return new Promise ( resolve, reject ) ->\n      lexer       = new_lexer { border_tokens: true, }\n      T?.eq lexer.cfg.border_tokens, true\n      # H.show_lexer_as_table 'new_syntax_for_modes', lexer; process.exit 111\n      result      = []\n      tokens      = []\n      for token from lexer.walk probe\n        tokens.push token\n        result.push GUY.props.pick_with_fallback token, null, 'mk', 'value', 'data'\n      result_rpr  = ( d.value for d in result when not d.$stamped ).join ''\n      H.tabulate \"#{rpr probe} -> #{rpr result_rpr}\", tokens\n      #.....................................................................................................\n      resolve result\n  #.........................................................................................................\n  done?()\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\n@singular_jumps_move_forward_correctly = ( T, done ) ->\n  { Interlex\n    compose  }        = require '../../../apps/intertext-lexer'\n  #.........................................................................................................\n  new_lexer = ( cfg = null ) ->\n    lexer   = new Interlex { split: 'lines', cfg..., }\n    #.........................................................................................................\n    do =>\n      mode = 'plain'\n      lexer.add_lexeme { mode, lxid: 'escchr', jump: null,       pattern: /\\\\(?<chr>.)/u,    reserved: '\\\\', }\n      lexer.add_lexeme { mode, lxid: 'c_lsr',  jump: '[tag]',    pattern: '</>',             reserved: '<', }\n      lexer.add_lexeme { mode, lxid: 'lpb',    jump: '[tag',     pattern: '<',               reserved: '<', }\n      lexer.add_catchall_lexeme { mode, lxid: 'text', concat: true, }\n      lexer.add_reserved_lexeme { mode, lxid: '$forbidden', concat: true, }\n    #.........................................................................................................\n    do =>\n      mode = 'tag'\n      lexer.add_lexeme { mode, lxid: 'escchr', jump: null,           pattern: /\\\\(?<chr>.)/u, reserved: '\\\\', }\n      lexer.add_lexeme { mode, lxid: 'lbp',    jump: null,           pattern: '<',            reserved: '<', }\n      lexer.add_lexeme { mode, lxid: 'rbp',    jump: null,           pattern: '>',            reserved: '>', }\n      lexer.add_catchall_lexeme { mode, lxid: 'text', concat: true, }\n      lexer.add_reserved_lexeme { mode, lxid: '$forbidden', concat: true, }\n    #.........................................................................................................\n    return lexer\n  #.........................................................................................................\n  probes_and_matchers = [\n    [ 'helo', [ { mk: 'plain:text', value: 'helo', data: null } ], null ]\n    [ 'abc</>def<what>', [ { mk: 'plain:text', value: 'abc', data: null }, { mk: 'plain:$border', value: '', data: { prv: 'plain', nxt: 'tag' } }, { mk: 'tag:c_lsr', value: '</>', data: null }, { mk: 'plain:$border', value: '', data: { prv: 'tag', nxt: 'plain' } }, { mk: 'plain:text', value: 'def', data: null }, { mk: 'tag:$border', value: '', data: { prv: 'plain', nxt: 'tag' } }, { mk: 'tag:lpb', value: '<', data: null }, { mk: 'tag:text', value: 'what', data: null }, { mk: 'tag:rbp', value: '>', data: null } ], null ]\n    ]\n  #.........................................................................................................\n  for [ probe, matcher, error, ] in probes_and_matchers\n    await T.perform probe, matcher, error, -> return new Promise ( resolve, reject ) ->\n      lexer       = new_lexer { border_tokens: true, }\n      T?.eq lexer.cfg.border_tokens, true\n      # H.show_lexer_as_table 'new_syntax_for_modes', lexer; process.exit 111\n      result      = []\n      tokens      = []\n      for token from lexer.walk probe\n        tokens.push token\n        result.push GUY.props.pick_with_fallback token, null, 'mk', 'value', 'data'\n      result_rpr  = ( d.value for d in result when not d.$stamped ).join ''\n      H.tabulate \"#{rpr probe} -> #{rpr result_rpr}\", tokens\n      #.....................................................................................................\n      resolve result\n  #.........................................................................................................\n  done?()\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\n@cannot_use_undeclared_mode = ( T, done ) ->\n  { Interlex\n    compose  }        = require '../../../apps/intertext-lexer'\n  #.........................................................................................................\n  new_lexer = ->\n    lexer   = new Interlex { split: 'lines', }\n    #.........................................................................................................\n    do =>\n      mode = 'plain'\n      lexer.add_lexeme { mode, lxid: 'escchr', jump: null,           pattern: /\\\\(?<chr>.)/u,  reserved: '\\\\', }\n      lexer.add_lexeme { mode, lxid: 'lpb',    jump: '[tag',         pattern: /</u,            reserved: '<', }\n      lexer.add_lexeme { mode, lxid: 'nl',     jump: null,           pattern: /$/u, value: '\\n', }\n      lexer.add_catchall_lexeme { mode, lxid: 'text', concat: true, }\n    #.........................................................................................................\n    do =>\n      mode = 'dq1'\n      lexer.add_lexeme { mode, lxid: 'escchr', jump: null,           pattern: /\\\\(?<chr>.)/u, reserved: '\\\\', }\n      lexer.add_lexeme { mode, lxid: 'rpb',    jump: '.]',           pattern: />/u, reserved: '>', }\n      lexer.add_lexeme { mode, lxid: 'nl',     jump: null,           pattern: /$/u, value: '\\n', }\n      lexer.add_catchall_lexeme { mode, lxid: 'text', concat: true, }\n    #.........................................................................................................\n    return lexer\n  #.........................................................................................................\n  probes_and_matchers = [\n    [ 'helo', null, 'xxxx' ]\n    ]\n  #.........................................................................................................\n  for [ probe, matcher, error, ] in probes_and_matchers\n    # await T.perform probe, matcher, error, -> return new Promise ( resolve, reject ) ->\n    error = null\n    lexer       = new_lexer()\n    # debug '^w342^', lexer.start()\n    T?.throws /no such mode/, -> lexer.start()\n  #.........................................................................................................\n  done?()\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\n@auto_inserted_border_posts_inclusive = ( T, done ) ->\n  { Interlex\n    compose  }        = require '../../../apps/intertext-lexer'\n  #.........................................................................................................\n  new_lexer = ( cfg ) ->\n    lexer   = new Interlex { split: 'lines', cfg..., }\n    #.........................................................................................................\n    do =>\n      mode = 'plain'\n      lexer.add_lexeme { mode, lxid: 'escchr', jump: null,           pattern: /\\\\(?<chr>.)/u,  reserved: '\\\\', }\n      lexer.add_lexeme { mode, lxid: 'lpb',    jump: '[tag',         pattern: /</u,            reserved: '<', }\n      lexer.add_lexeme { mode, lxid: 'nl',     jump: null,           pattern: /$/u, value: '\\n', }\n      lexer.add_catchall_lexeme { mode, lxid: 'text', concat: true, }\n    #.........................................................................................................\n    do =>\n      mode = 'tag'\n      lexer.add_lexeme { mode, lxid: 'escchr', jump: null,           pattern: /\\\\(?<chr>.)/u, reserved: '\\\\', }\n      lexer.add_lexeme { mode, lxid: 'rpb',    jump: '.]',           pattern: />/u, reserved: '>', }\n      lexer.add_lexeme { mode, lxid: 'nl',     jump: null,           pattern: /$/u, value: '\\n', }\n      lexer.add_catchall_lexeme { mode, lxid: 'text', concat: true, }\n    #.........................................................................................................\n    return lexer\n  #.........................................................................................................\n  probes_and_matchers = [\n    [ 'helo', [ { mk: 'plain:text', value: 'helo', x1: 0, x2: 4 }, { mk: 'plain:nl', value: '\\n', x1: 4, x2: 4 } ], null ]\n    [ 'helo<t1>', [ { mk: 'plain:text', value: 'helo', x1: 0, x2: 4 }, { mk: 'tag:$border', value: '|', x1: 4, x2: 4 }, { mk: 'tag:lpb', value: '<', x1: 4, x2: 5 }, { mk: 'tag:text', value: 't1', x1: 5, x2: 7 }, { mk: 'tag:rpb', value: '>', x1: 7, x2: 8 }, { mk: 'plain:$border', value: '|', x1: 8, x2: 8 }, { mk: 'plain:nl', value: '\\n', x1: 8, x2: 8 } ], null ]\n    [ 'helo<t1><t2>', [ { mk: 'plain:text', value: 'helo', x1: 0, x2: 4 }, { mk: 'tag:$border', value: '|', x1: 4, x2: 4 }, { mk: 'tag:lpb', value: '<', x1: 4, x2: 5 }, { mk: 'tag:text', value: 't1', x1: 5, x2: 7 }, { mk: 'tag:rpb', value: '>', x1: 7, x2: 8 }, { mk: 'plain:$border', value: '|', x1: 8, x2: 8 }, { mk: 'tag:$border', value: '|', x1: 8, x2: 8 }, { mk: 'tag:lpb', value: '<', x1: 8, x2: 9 }, { mk: 'tag:text', value: 't2', x1: 9, x2: 11 }, { mk: 'tag:rpb', value: '>', x1: 11, x2: 12 }, { mk: 'plain:$border', value: '|', x1: 12, x2: 12 }, { mk: 'plain:nl', value: '\\n', x1: 12, x2: 12 } ], null ]\n    [ 'helo<t1><t2', [ { mk: 'plain:text', value: 'helo', x1: 0, x2: 4 }, { mk: 'tag:$border', value: '|', x1: 4, x2: 4 }, { mk: 'tag:lpb', value: '<', x1: 4, x2: 5 }, { mk: 'tag:text', value: 't1', x1: 5, x2: 7 }, { mk: 'tag:rpb', value: '>', x1: 7, x2: 8 }, { mk: 'plain:$border', value: '|', x1: 8, x2: 8 }, { mk: 'tag:$border', value: '|', x1: 8, x2: 8 }, { mk: 'tag:lpb', value: '<', x1: 8, x2: 9 }, { mk: 'tag:text', value: 't2', x1: 9, x2: 11 }, { mk: 'tag:nl', value: '\\n', x1: 11, x2: 11 } ], null ]\n    ]\n  #.........................................................................................................\n  for [ probe, matcher, error, ] in probes_and_matchers\n    # await T.perform probe, matcher, error, -> return new Promise ( resolve, reject ) ->\n    lexer       = new_lexer { border_tokens: true, border_value: '|', }\n    T?.eq lexer.cfg.border_tokens, true\n    T?.eq lexer.cfg.border_value, '|'\n    # H.show_lexer_as_table 'new_syntax_for_modes', lexer; process.exit 111\n    result      = []\n    tokens      = []\n    for token from lexer.walk probe\n      tokens.push token\n      result.push GUY.props.pick_with_fallback token, null, 'mk', 'value', 'x1', 'x2'\n    result_rpr  = ( d.value for d in result when not d.$stamped ).join ''\n    echo [ probe, result, error, ]\n    # H.tabulate \"#{rpr probe} -> #{rpr result_rpr}\", tokens\n    #.....................................................................................................\n    T?.eq result, matcher\n  #.........................................................................................................\n  done?()\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\n@auto_inserted_border_posts_exclusive = ( T, done ) ->\n  { Interlex\n    compose  }        = require '../../../apps/intertext-lexer'\n  #.........................................................................................................\n  new_lexer = ( cfg ) ->\n    lexer   = new Interlex { split: 'lines', cfg..., }\n    #.........................................................................................................\n    do =>\n      mode = 'plain'\n      lexer.add_lexeme { mode, lxid: 'escchr', jump: null,           pattern: /\\\\(?<chr>.)/u,  reserved: '\\\\', }\n      lexer.add_lexeme { mode, lxid: 'lpb',    jump: 'tag[',         pattern: /</u,            reserved: '<', }\n      lexer.add_lexeme { mode, lxid: 'nl',     jump: null,           pattern: /$/u, value: '\\n', }\n      lexer.add_catchall_lexeme { mode, lxid: 'text', concat: true, }\n    #.........................................................................................................\n    do =>\n      mode = 'tag'\n      lexer.add_lexeme { mode, lxid: 'escchr', jump: null,           pattern: /\\\\(?<chr>.)/u, reserved: '\\\\', }\n      lexer.add_lexeme { mode, lxid: 'rpb',    jump: '].',           pattern: />/u, reserved: '>', }\n      lexer.add_lexeme { mode, lxid: 'nl',     jump: null,           pattern: /$/u, value: '\\n', }\n      lexer.add_catchall_lexeme { mode, lxid: 'text', concat: true, }\n    #.........................................................................................................\n    return lexer\n  #.........................................................................................................\n  probes_and_matchers = [\n    [ 'helo', [ { $key: 'plain:text', value: 'helo', x1: 0, x2: 4 }, { $key: 'plain:nl', value: '\\n', x1: 4, x2: 4 } ], null ]\n    # [ 'helo<t1>', [ { $key: 'plain:text', value: 'helo', x1: 0, x2: 4 }, { $key: 'plain:lpb', value: '<', x1: 4, x2: 5 }, { $key: 'tag:$border', value: '|', x1: 5, x2: 5 }, { $key: 'tag:text', value: 't1', x1: 5, x2: 7 }, { $key: 'plain:$border', value: '|', x1: 7, x2: 7 }, { $key: 'plain:rpb', value: '>', x1: 7, x2: 8 }, { $key: 'plain:nl', value: '\\n', x1: 8, x2: 8 } ], null ]\n    # [ 'helo<t1><t2>', [ { $key: 'plain:text', value: 'helo', x1: 0, x2: 4 }, { $key: 'plain:lpb', value: '<', x1: 4, x2: 5 }, { $key: 'tag:$border', value: '|', x1: 5, x2: 5 }, { $key: 'tag:text', value: 't1', x1: 5, x2: 7 }, { $key: 'plain:$border', value: '|', x1: 7, x2: 7 }, { $key: 'plain:rpb', value: '>', x1: 7, x2: 8 }, { $key: 'plain:lpb', value: '<', x1: 8, x2: 9 }, { $key: 'tag:$border', value: '|', x1: 9, x2: 9 }, { $key: 'tag:text', value: 't2', x1: 9, x2: 11 }, { $key: 'plain:$border', value: '|', x1: 11, x2: 11 }, { $key: 'plain:rpb', value: '>', x1: 11, x2: 12 }, { $key: 'plain:nl', value: '\\n', x1: 12, x2: 12 } ], null ]\n    # [ 'helo<t1><t2', [ { $key: 'plain:text', value: 'helo', x1: 0, x2: 4 }, { $key: 'plain:lpb', value: '<', x1: 4, x2: 5 }, { $key: 'tag:$border', value: '|', x1: 5, x2: 5 }, { $key: 'tag:text', value: 't1', x1: 5, x2: 7 }, { $key: 'plain:$border', value: '|', x1: 7, x2: 7 }, { $key: 'plain:rpb', value: '>', x1: 7, x2: 8 }, { $key: 'plain:lpb', value: '<', x1: 8, x2: 9 }, { $key: 'tag:$border', value: '|', x1: 9, x2: 9 }, { $key: 'tag:text', value: 't2', x1: 9, x2: 11 }, { $key: 'tag:nl', value: '\\n', x1: 11, x2: 11 } ], null ]\n    ]\n  #.........................................................................................................\n  for [ probe, matcher, error, ] in probes_and_matchers\n    # await T.perform probe, matcher, error, -> return new Promise ( resolve, reject ) ->\n    lexer       = new_lexer { border_tokens: true, border_value: '|', }\n    T?.eq lexer.cfg.border_tokens, true\n    T?.eq lexer.cfg.border_value, '|'\n    # H.show_lexer_as_table 'new_syntax_for_modes', lexer; process.exit 111\n    result      = []\n    tokens      = []\n    for token from lexer.walk probe\n      tokens.push token\n      result.push GUY.props.pick_with_fallback token, null, '$key', 'value', 'x1', 'x2'\n    result_rpr  = ( d.value for d in result when not d.$stamped ).join ''\n    echo [ probe, result, error, ]\n    H.norm_tabulate \"#{rpr probe} -> #{rpr result_rpr}\", tokens\n    #.....................................................................................................\n    T?.eq result, matcher\n  #.........................................................................................................\n  done?()\n  return null\n\n\n#===========================================================================================================\n# JUMP FUNCTIONS\n#-----------------------------------------------------------------------------------------------------------\n@markup_with_variable_length = ( T, done ) ->\n  { Pipeline,         \\\n    $,\n    transforms,     } = require '../../../apps/moonriver'\n  { Interlex\n    compose  }        = require '../../../apps/intertext-lexer'\n  { DATOM }           = require '../../../apps/datom'\n  { new_datom }       = DATOM\n  first               = Symbol 'first'\n  last                = Symbol 'last'\n  #.........................................................................................................\n  new_toy_md_lexer = ( mode = 'plain' ) ->\n    lexer           = new Interlex { dotall: false, }\n    backtick_count  = null\n    #.......................................................................................................\n    enter_codespan = ({ token, match, lexer, }) ->\n      # debug '^35-1^', match\n      backtick_count = token.value.length\n      return { jump: 'literal[', }\n    #.......................................................................................................\n    exit_codespan = ({ token, match, lexer, }) ->\n      # debug '^35-3^', match\n      if token.value.length is backtick_count\n        backtick_count = null\n        return '.]'\n      token = lets token, ( token ) -> token.$key = \"#{token.mode}:text\"\n      return { token, }\n    #.......................................................................................................\n    lexer.add_lexeme { mode: 'plain',   lxid: 'escchr',    jump: null,           pattern:  /\\\\(?<chr>.)/u,     }\n    lexer.add_lexeme { mode: 'plain',   lxid: 'star1',     jump: null,           pattern:  /(?<!\\*)\\*(?!\\*)/u, }\n    lexer.add_lexeme { mode: 'plain',   lxid: 'codespan',  jump: enter_codespan, pattern:  /(?<!`)`+(?!`)/u,   }\n    lexer.add_lexeme { mode: 'plain',   lxid: 'other',     jump: null,           pattern:  /[^*`\\\\]+/u,        }\n    lexer.add_lexeme { mode: 'literal', lxid: 'codespan',  jump: exit_codespan,  pattern:  /(?<!`)`+(?!`)/u,   }\n    lexer.add_lexeme { mode: 'literal', lxid: 'text',      jump: null,           pattern:  /(?:\\\\`|[^`])+/u,   }\n    #.......................................................................................................\n    return lexer\n  #.........................................................................................................\n  $parse_md_codespan = ->\n    return ( d, send ) ->\n      switch d.$key\n        when  'plain:codespan'\n          send stamp d\n          send new_datom 'html:tag', { value: '<code>', }\n        when 'literal:codespan'\n          send stamp d\n          send new_datom 'html:tag', { value: '</code>', }\n        else\n          send d\n      return null\n  #.........................................................................................................\n  probes_and_matchers = [\n    [ \"*abc*\", \"<i>abc</i>\", ]\n    [ 'helo `world`!', 'helo <code>world</code>!', null ]\n    [ '*foo* `*bar*` baz', '<i>foo</i> <code>*bar*</code> baz', null ]\n    [ '*foo* ``*bar*`` baz', '<i>foo</i> <code>*bar*</code> baz', null ]\n    [ '*foo* ````*bar*```` baz', '<i>foo</i> <code>*bar*</code> baz', null ]\n    [ '*foo* ``*bar*``` baz', '<i>foo</i> <code>*bar*``` baz', null ]\n    [ '*foo* ```*bar*`` baz', '<i>foo</i> <code>*bar*`` baz', null ]\n    ]\n  #.........................................................................................................\n  for [ probe, matcher, error, ] in probes_and_matchers\n    await T.perform probe, matcher, error, -> return new Promise ( resolve, reject ) ->\n      md_lexer  = new_toy_md_lexer 'md'\n      #.....................................................................................................\n      p = new Pipeline()\n      p.push ( source, send ) -> send e for e from md_lexer.walk source\n      p.push H.$parse_md_star()\n      p.push $parse_md_codespan()\n      #.....................................................................................................\n      p.send probe\n      result      = p.run()\n      result_rpr  = ( d.value for d in result when not d.$stamped ).join ''\n      # urge '^08-1^', ( Object.keys d ).sort() for d in result\n      H.tabulate \"#{probe} -> #{result_rpr} (#{matcher})\", result # unless result_rpr is matcher\n      #.....................................................................................................\n      resolve result_rpr\n  #.........................................................................................................\n  done?()\n  return null\n\n\n\n\n\n############################################################################################################\nif require.main is module then do =>\n  # test @\n  # test @markup_with_variable_length\n  # test @auto_inserted_border_posts_exclusive\n  # @singular_jumps()\n  test @singular_jumps\n"
  ]
}