{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/test-modes.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n'use strict'\n\n\n############################################################################################################\nGUY                       = require 'guy'\n{ alert\n  debug\n  help\n  info\n  plain\n  praise\n  urge\n  warn\n  whisper }               = GUY.trm.get_loggers 'INTERTEXT-LEXER/TESTS/MODES'\n{ rpr\n  inspect\n  echo\n  log     }               = GUY.trm\n#...........................................................................................................\ntest                      = require '../../../apps/guy-test'\n# PATH                      = require 'path'\n# FS                        = require 'fs'\ntypes                     = new ( require 'intertype' ).Intertype\n{ isa\n  equals\n  type_of\n  validate\n  validate_list_of }      = types.export()\nH                         = require './helpers'\n\n\n#-----------------------------------------------------------------------------------------------------------\n@new_syntax_for_in_and_exclusive_jumps_1 = ( T, done ) ->\n  { Interlex\n    compose  }        = require '../../../apps/intertext-lexer'\n  #.........................................................................................................\n  new_lexer = ->\n    lexer   = new Interlex { split: 'lines', }\n    #.........................................................................................................\n    do =>\n      mode = 'plain'\n      lexer.add_lexeme { mode, tid: 'escchr', jump: null,           pattern: /\\\\(?<chr>.)/u, reserved: '\\\\', }\n      lexer.add_lexeme { mode, tid: 'dq1',    jump: 'dq1[',         pattern: /(?<!\")\"(?!\")/u, reserved: '\"', }\n      lexer.add_lexeme { mode, tid: 'nl',     jump: null,           pattern: /$/u, value: '\\n', }\n      lexer.add_catchall_lexeme { mode, tid: 'text', concat: true, }\n    #.........................................................................................................\n    do =>\n      mode = 'dq1'\n      lexer.add_lexeme { mode, tid: 'escchr', jump: null,           pattern: /\\\\(?<chr>.)/u, reserved: '\\\\', }\n      lexer.add_lexeme { mode, tid: 'dq1',    jump: '.]',           pattern: /\"/u, reserved: '\"', }\n      lexer.add_lexeme { mode, tid: 'nl',     jump: null,           pattern: /$/u, value: '\\n', }\n      lexer.add_catchall_lexeme { mode, tid: 'text', concat: true, }\n    #.........................................................................................................\n    return lexer\n  #.........................................................................................................\n  probes_and_matchers = [\n    [ 'helo', [ { mk: 'plain:text', value: 'helo' }, { mk: 'plain:nl', value: '\\n' } ], null ]\n    [ 'helo \"world\"', [ { mk: 'plain:text', value: 'helo ' }, { mk: 'plain:dq1', value: '\"' }, { mk: 'dq1:text', value: 'world' }, { mk: 'dq1:dq1', value: '\"' }, { mk: 'plain:nl', value: '\\n' } ], null ]\n    [ 'helo \"everyone\\nout there\"!', [ { mk: 'plain:text', value: 'helo ' }, { mk: 'plain:dq1', value: '\"' }, { mk: 'dq1:text', value: 'everyone' }, { mk: 'dq1:nl', value: '\\n' }, { mk: 'dq1:text', value: 'out there' }, { mk: 'dq1:dq1', value: '\"' }, { mk: 'plain:text', value: '!' }, { mk: 'plain:nl', value: '\\n' } ], null ]\n    ]\n  #.........................................................................................................\n  # for [ probe, matcher, error, ] in probes_and_matchers\n  #     lexer       = new_lexer()\n  #     # H.show_lexer_as_table 'new_syntax_for_modes', lexer; process.exit 111\n  #     result      = []\n  #     for token from lexer.walk probe\n  #       result.push GUY.props.pick_with_fallback token, null, 'mk', 'value'\n  #     result_rpr  = ( d.value for d in result when not d.$stamped ).join ''\n  #     H.tabulate \"#{rpr probe} -> #{rpr result_rpr}\", result # unless result_rpr is matcher\n  for [ probe, matcher, error, ] in probes_and_matchers\n    await T.perform probe, matcher, error, -> return new Promise ( resolve, reject ) ->\n      lexer       = new_lexer()\n      # H.show_lexer_as_table 'new_syntax_for_modes', lexer; process.exit 111\n      result      = []\n      for token from lexer.walk probe\n        result.push GUY.props.pick_with_fallback token, null, 'mk', 'value'\n      result_rpr  = ( d.value for d in result when not d.$stamped ).join ''\n      # H.tabulate \"#{rpr probe} -> #{rpr result_rpr}\", result # unless result_rpr is matcher\n      #.....................................................................................................\n      resolve result\n  #.........................................................................................................\n  done?()\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\n@new_syntax_for_in_and_exclusive_jumps_2 = ( T, done ) ->\n  { Interlex\n    compose  }        = require '../../../apps/intertext-lexer'\n  #.........................................................................................................\n  new_lexer = ->\n    lexer   = new Interlex { split: 'lines', }\n    #.........................................................................................................\n    do =>\n      mode = 'plain'\n      lexer.add_lexeme { mode, tid: 'escchr', jump: null,           pattern: /\\\\(?<chr>.)/u,  reserved: '\\\\', }\n      lexer.add_lexeme { mode, tid: 'dq1',    jump: '[dq1',         pattern: /\"/u,            reserved: '\"', }\n      lexer.add_lexeme { mode, tid: 'nl',     jump: null,           pattern: /$/u, value: '\\n', }\n      lexer.add_catchall_lexeme { mode, tid: 'text', concat: true, }\n    #.........................................................................................................\n    do =>\n      mode = 'dq1'\n      lexer.add_lexeme { mode, tid: 'escchr', jump: null,           pattern: /\\\\(?<chr>.)/u, reserved: '\\\\', }\n      lexer.add_lexeme { mode, tid: 'dq1',    jump: '].',           pattern: /\"/u, reserved: '\"', }\n      lexer.add_lexeme { mode, tid: 'nl',     jump: null,           pattern: /$/u, value: '\\n', }\n      lexer.add_catchall_lexeme { mode, tid: 'text', concat: true, }\n    #.........................................................................................................\n    return lexer\n  #.........................................................................................................\n  probes_and_matchers = [\n    [ 'helo', [ { mk: 'plain:text', value: 'helo' }, { mk: 'plain:nl', value: '\\n' } ], null ]\n    [ 'helo \"world\"', [ { mk: 'plain:text', value: 'helo ' }, { mk: 'dq1:dq1', value: '\"' }, { mk: 'dq1:text', value: 'world' }, { mk: 'plain:dq1', value: '\"' }, { mk: 'plain:nl', value: '\\n' } ], null ]\n    [ 'helo \"everyone\\nout there\"!', [ { mk: 'plain:text', value: 'helo ' }, { mk: 'dq1:dq1', value: '\"' }, { mk: 'dq1:text', value: 'everyone' }, { mk: 'dq1:nl', value: '\\n' }, { mk: 'dq1:text', value: 'out there' }, { mk: 'plain:dq1', value: '\"' }, { mk: 'plain:text', value: '!' }, { mk: 'plain:nl', value: '\\n' } ], null ]\n    [ '\"one\"\"two\"', [ { mk: 'dq1:dq1', value: '\"' }, { mk: 'dq1:text', value: 'one' }, { mk: 'plain:dq1', value: '\"' }, { mk: 'dq1:dq1', value: '\"' }, { mk: 'dq1:text', value: 'two' }, { mk: 'plain:dq1', value: '\"' }, { mk: 'plain:nl', value: '\\n' } ], null ]\n    ]\n  #.........................................................................................................\n  for [ probe, matcher, error, ] in probes_and_matchers\n    await T.perform probe, matcher, error, -> return new Promise ( resolve, reject ) ->\n      lexer       = new_lexer()\n      # H.show_lexer_as_table 'new_syntax_for_modes', lexer; process.exit 111\n      result      = []\n      tokens      = []\n      for token from lexer.walk probe\n        tokens.push token\n        result.push GUY.props.pick_with_fallback token, null, 'mk', 'value'\n      result_rpr  = ( d.value for d in result when not d.$stamped ).join ''\n      H.tabulate \"#{rpr probe} -> #{rpr result_rpr}\", tokens\n      #.....................................................................................................\n      resolve result\n  #.........................................................................................................\n  done?()\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\n@new_syntax_for_in_and_exclusive_jumps_3 = ( T, done ) ->\n  { Interlex\n    compose  }        = require '../../../apps/intertext-lexer'\n  #.........................................................................................................\n  new_lexer = ->\n    lexer   = new Interlex { split: 'lines', }\n    #.........................................................................................................\n    do =>\n      mode = 'plain'\n      lexer.add_lexeme { mode, tid: 'escchr', jump: null,           pattern: /\\\\(?<chr>.)/u,  reserved: '\\\\', }\n      lexer.add_lexeme { mode, tid: 'dq1',    jump: '[dq1',         pattern: /\"/u,            reserved: '\"', }\n      lexer.add_lexeme { mode, tid: 'nl',     jump: null,           pattern: /$/u, value: '\\n', }\n      lexer.add_catchall_lexeme { mode, tid: 'text', concat: true, }\n    #.........................................................................................................\n    do =>\n      mode = 'dq1'\n      lexer.add_lexeme { mode, tid: 'escchr', jump: null,           pattern: /\\\\(?<chr>.)/u, reserved: '\\\\', }\n      lexer.add_lexeme { mode, tid: 'dq1',    jump: '.]',           pattern: /\"/u, reserved: '\"', }\n      lexer.add_lexeme { mode, tid: 'nl',     jump: null,           pattern: /$/u, value: '\\n', }\n      lexer.add_catchall_lexeme { mode, tid: 'text', concat: true, }\n    #.........................................................................................................\n    return lexer\n  #.........................................................................................................\n  probes_and_matchers = [\n    [ 'helo', [ { mk: 'plain:text', value: 'helo' }, { mk: 'plain:nl', value: '\\n' } ], null ]\n    [ 'helo \"world\"', [ { mk: 'plain:text', value: 'helo ' }, { mk: 'dq1:dq1', value: '\"' }, { mk: 'dq1:text', value: 'world' }, { mk: 'dq1:dq1', value: '\"' }, { mk: 'plain:nl', value: '\\n' } ], null ]\n    [ 'helo \"everyone\\nout there\"!', [ { mk: 'plain:text', value: 'helo ' }, { mk: 'dq1:dq1', value: '\"' }, { mk: 'dq1:text', value: 'everyone' }, { mk: 'dq1:nl', value: '\\n' }, { mk: 'dq1:text', value: 'out there' }, { mk: 'dq1:dq1', value: '\"' }, { mk: 'plain:text', value: '!' }, { mk: 'plain:nl', value: '\\n' } ], null ]\n    [ '\"one\"\"two\"', [ { mk: 'dq1:dq1', value: '\"' }, { mk: 'dq1:text', value: 'one' }, { mk: 'dq1:dq1', value: '\"' }, { mk: 'dq1:dq1', value: '\"' }, { mk: 'dq1:text', value: 'two' }, { mk: 'dq1:dq1', value: '\"' }, { mk: 'plain:nl', value: '\\n' } ], null ]\n    ]\n  #.........................................................................................................\n  for [ probe, matcher, error, ] in probes_and_matchers\n    await T.perform probe, matcher, error, -> return new Promise ( resolve, reject ) ->\n      lexer       = new_lexer()\n      # H.show_lexer_as_table 'new_syntax_for_modes', lexer; process.exit 111\n      result      = []\n      tokens      = []\n      for token from lexer.walk probe\n        tokens.push token\n        result.push GUY.props.pick_with_fallback token, null, 'mk', 'value'\n      result_rpr  = ( d.value for d in result when not d.$stamped ).join ''\n      H.tabulate \"#{rpr probe} -> #{rpr result_rpr}\", tokens\n      #.....................................................................................................\n      resolve result\n  #.........................................................................................................\n  done?()\n  return null\n\n\n############################################################################################################\nif require.main is module then do =>\n  test @\n\n"
  ]
}