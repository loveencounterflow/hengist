{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/second-demo.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n'use strict'\n\n\n############################################################################################################\nGUY                       = require 'guy'\n{ alert\n  debug\n  help\n  info\n  plain\n  praise\n  urge\n  warn\n  whisper }               = GUY.trm.get_loggers 'DEMO-COMPOSE-REGEXP'\n{ rpr\n  inspect\n  echo\n  log     }               = GUY.trm\ntruth                     = GUY.trm.truth.bind GUY.trm\n#...........................................................................................................\n{ equals\n  copy_regex }            = GUY.samesame\n{ to_width }              = require 'to-width'\n#...........................................................................................................\n{ atomic\n  bound\n  capture\n  charSet\n  either\n  flags\n  lookAhead\n  lookBehind\n  maybe\n  namedCapture\n  noBound\n  notAhead\n  notBehind\n  ref\n  sequence\n  suffix                } = require 'compose-regexp-commonjs'\nH                         = require '../../../lib/helpers'\n{ Interlex }              = require '../../../apps/intertext-lexer'\n\n\n#-----------------------------------------------------------------------------------------------------------\nunicode = ( x ) -> if ( x instanceof RegExp ) then copy_regex x, { unicode: true, } else flags.add 'u', x\nsticky  = ( x ) -> if ( x instanceof RegExp ) then copy_regex x, { sticky: true,  } else flags.add 'y', x\ndotall  = ( x ) -> if ( x instanceof RegExp ) then copy_regex x, { dotAll: true,  } else flags.add 's', x\ndotAll  = dotall\n\n#-----------------------------------------------------------------------------------------------------------\ndemo_htmlish = ->\n  n       = namedCapture\n  modes   = {}\n  lexer   = new Interlex()\n  #.........................................................................................................\n  do =>\n    ### NOTE arbitrarily forbidding question marks and not using fallback token to test for error tokens ###\n    mode    = 'plain'\n    lexer.add_lexeme mode, 'escchr',       /\\\\(?<chr>.)/u\n    lexer.add_lexeme mode, 'text',         suffix '+', charSet.complement /[<`\\\\?]/u\n    lexer.add_lexeme mode, 'start_tag',    /<(?<lslash>\\/?)/u\n    lexer.add_lexeme mode, 'E_backticks',  /`+/\n    # lexer.add_lexeme mode, 'other',        /./u\n  #.........................................................................................................\n  do =>\n    mode    = 'tag'\n    lexer.add_lexeme mode, 'escchr',       /\\\\(?<chr>.)/u\n    lexer.add_lexeme mode, 'stop_tag',     />/u\n    # lexer.add_lexeme mode, 'stop_tag',     either ( sequence ( notBehind '\\\\' ), />/u ), ( /^>/u )\n    lexer.add_lexeme mode, 'text',         suffix '+', charSet.complement /[>\\\\]/u\n    lexer.add_lexeme mode, 'other',        /./u\n  #.........................................................................................................\n  lexer.finalize()\n  #.........................................................................................................\n  probes        = [\n    # \"helo <bold>`world`</bold>\"\n    # \"<x v=\\\\> z=42>\"\n    \"<x v=\\\\> z=42\\\\>\"\n    \"a <b\"\n    \"what? error?\"\n    \"d <\"\n    \"<c\"\n    \"<\"\n    \"\"\n    # \"helo \\\\<bold>`world`</bold>\"\n    ]\n  #.......................................................................................................\n  for probe in probes\n    whisper '^31-1^', '————————————————————————————————————————————————————————————————————————'\n    lexer.reset()\n    pattern   = lexer.registry[ lexer.state.mode ].pattern\n    tokens    = []\n    max_index = probe.length - 1\n    #.......................................................................................................\n    loop\n      if lexer.state.prv_last_idx > max_index\n        ### reached end ###\n        tokens.push { mode: lexer.state.mode, key: '$eof', mk: \"#{lexer.state.mode}:$eof\", \\\n          value: '', start: max_index + 1, stop: max_index + 1, x: null, }\n        break\n      match = probe.match pattern\n      unless match?\n        ### TAINT complain if not at end or issue error token ###\n        warn '^31-6^', GUY.trm.reverse \"no match\"\n        tokens.push { mode: lexer.state.mode, key: '$error', mk: \"#{lexer.state.mode}:$error\", \\\n          value: '', start: lexer.state.prv_last_idx, stop: lexer.state.prv_last_idx, x: { code: 'nomatch', }, }\n        break\n      if pattern.lastIndex is lexer.state.prv_last_idx\n        if match?\n          warn '^31-7^', { match.groups..., }\n          warn '^31-8^', token  = lexer._token_from_match lexer.state.prv_last_idx, match, lexer.state.mode\n          ### TAINT uses code units, should use codepoints ###\n          center = token.stop\n          left   = Math.max 0, center - 11\n          right  = Math.min probe.length, center + 11\n          before = probe[ left ... center ]\n          after  = probe[ center + 1 .. right ]\n          mid    = probe[ center ]\n          warn '^31-9^', { before, mid, after, }\n          warn '^31-10^', GUY.trm.reverse \"pattern #{rpr token.key} matched empty string; stopping\"\n        else\n          warn '^31-11^', GUY.trm.reverse \"nothing matched; detected loop, stopping\"\n        break\n      token = lexer._token_from_match lexer.state.prv_last_idx, match, lexer.state.mode\n      tokens.push token\n      # info '^31-12^', pattern.lastIndex, token\n      #.....................................................................................................\n      if token.key.startsWith 'start_'\n        lexer.state.stack.push lexer.state.mode\n        lexer.state.mode              = token.key.replace 'start_', ''\n        old_last_idx      = pattern.lastIndex\n        pattern           = lexer.registry[ lexer.state.mode ].pattern\n        pattern.lastIndex = old_last_idx\n      #.....................................................................................................\n      else if token.key.startsWith 'stop_'\n        # error if lexer.state.stack.length < 1\n        lexer.state.mode              = lexer.state.stack.pop()\n        old_last_idx      = pattern.lastIndex\n        pattern           = lexer.registry[ lexer.state.mode ].pattern\n        pattern.lastIndex = old_last_idx\n      #.....................................................................................................\n      echo() if token.key is 'nl'\n      lexer.state.prv_last_idx = pattern.lastIndex\n    debug '^31-13^', lexer.state\n    H.tabulate \"tokens of #{rpr probe}\", tokens\n  #.......................................................................................................\n  return null\n\n\n############################################################################################################\nif module is require.main then do =>\n  # demo_1()\n  # demo_flags()\n  demo_htmlish()\n\n\n"
  ]
}