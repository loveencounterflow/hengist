{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/test-sorter.coffee"
  ],
  "names": [],
  "mappings": "AACA;EAAA;AAAA,MAAA,KAAA,EAAA,GAAA,EAAA,CAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,EAAA,KAAA,EAAA,KAAA,EAAA,KAAA,EAAA,IAAA,EAAA,MAAA,EAAA,GAAA,EAAA,IAAA,EAAA,IAAA,EAAA,OAAA,EAAA,GAAA,EAAA,IAAA,EAAA,GAAA,EAAA,SAAA,EAAA,KAAA,EAAA,MAAA,EAAA,GAAA,EAAA,KAAA,EAAA,IAAA,EAAA,OAAA,EAAA,KAAA,EAAA,IAAA,EAAA,QAAA,EAAA,gBAAA,EAAA,IAAA,EAAA,OAAA;;;EAIA,GAAA,GAA4B,OAAA,CAAQ,KAAR;;EAC5B,CAAA,CAAE,KAAF,EACE,KADF,EAEE,IAFF,EAGE,IAHF,EAIE,KAJF,EAKE,MALF,EAME,IANF,EAOE,IAPF,EAQE,OARF,CAAA,GAQ4B,GAAG,CAAC,GAAG,CAAC,WAAR,CAAoB,8BAApB,CAR5B;;EASA,CAAA,CAAE,GAAF,EACE,OADF,EAEE,IAFF,EAGE,GAHF,CAAA,GAG4B,GAAG,CAAC,GAHhC,EAdA;;;EAmBA,IAAA,GAA4B,OAAA,CAAQ,wBAAR;;EAC5B,IAAA,GAA4B,OAAA,CAAQ,MAAR,EApB5B;;;EAsBA,KAAA,GAA4B,IAAI,CAAE,OAAA,CAAQ,WAAR,CAAF,CAAuB,CAAC,SAA5B,CAAA;;EAC5B,CAAA,CAAE,GAAF,EACE,MADF,EAEE,OAFF,EAGE,QAHF,EAIE,gBAJF,CAAA,GAI4B,KAAK,CAAC,MAAN,CAAA,CAJ5B;;EAKA,GAAA,GAA4B,MAAM,CAAC;;EACnC,GAAA,GAA4B,OAAA,CAAQ,mBAAR;;EAC5B,CAAA,GAA4B,OAAA,CAAQ,sBAAR;;EAC5B,EAAA,GAA4B,OAAA,CAAQ,WAAR;;EAC5B,KAAA,GAA4B,CAAE,GAAF,EAAO,CAAP,CAAA,GAAA;WAAe,IAAI,OAAJ,CAAY,QAAA,CAAE,OAAF,CAAA;aAAe,UAAA,CAAW,CAAE,QAAA,CAAA,CAAA;eAAG,OAAA,CAAQ,CAAA,CAAA,CAAR;MAAH,CAAF,CAAX,EAA+B,GAAA,GAAM,IAArC;IAAf,CAAZ;EAAf;;EAC5B,CAAA,CAAE,KAAF,CAAA,GAA4B,OAAA,CAAQ,qBAAR,CAA5B;;EACA,CAAA,CAAE,SAAF,EACE,IADF,EAEE,KAFF,CAAA,GAE4B,KAF5B,EAlCA;;;;;EA4CA,IAAC,CAAA,cAAD,GAAkB,MAAA,QAAA,CAAE,CAAF,EAAK,IAAL,CAAA;AAClB,QAAA,CAAA,EAAA,QAAA,EAAA,QAAA,EAAA,OAAA,EAAA,KAAA,EAAA,KAAA,EAAA,CAAA,EAAA,IAAA,EAAA,GAAA,EAAA,OAAA,EAAA,SAAA,EAAA,KAAA,EAAA,mBAAA,EAAA;IAAE,CAAA,CAAE,QAAF,EACE,CADF,EAEE,UAFF,CAAA,GAEsB,OAAA,CAAQ,yBAAR,CAFtB;IAGA,CAAA,CAAE,QAAF,EACE,OADF,CAAA,GACsB,OAAA,CAAQ,+BAAR,CADtB;IAEA,KAAA,GAAsB,MAAA,CAAO,OAAP;IACtB,IAAA,GAAsB,MAAA,CAAO,MAAP,EANxB;;IAQE,SAAA,GAAY,QAAA,CAAE,OAAO,OAAT,CAAA;AACd,UAAA;MAAI,KAAA,GAAU,IAAI,QAAJ,CAAa;QAAE,QAAA,EAAU;MAAZ,CAAb,EAAd;;MAEI,KAAK,CAAC,UAAN,CAAiB;QAAE,IAAF;QAAQ,GAAA,EAAK,MAAb;QAAuB,OAAA,EAAS;MAAhC,CAAjB;MACA,KAAK,CAAC,UAAN,CAAiB;QAAE,IAAF;QAAQ,GAAA,EAAK,IAAb;QAAuB,OAAA,EAAS;MAAhC,CAAjB;MACA,KAAK,CAAC,UAAN,CAAiB;QAAE,IAAF;QAAQ,GAAA,EAAK,QAAb;QAAuB,OAAA,EAAS;MAAhC,CAAjB,EAJJ;;AAMI,aAAO;IAPG,EARd;;IAiBE,mBAAA,GAAsB,CACpB,CAAE,OAAF,EAAW,YAAX,EAAyB,IAAzB,CADoB,EAEpB,CAAE,YAAF,EAAgB,mBAAhB,EAAqC,IAArC,CAFoB,EAjBxB;;IAsBE,KAAA,qDAAA;MAAI,CAAE,KAAF,EAAS,OAAT,EAAkB,KAAlB;MACF,MAAM,CAAC,CAAC,OAAF,CAAU,KAAV,EAAiB,OAAjB,EAA0B,KAA1B,EAAiC,QAAA,CAAA,CAAA;AAAG,eAAO,IAAI,OAAJ,CAAY,QAAA,CAAE,OAAF,EAAW,MAAX,CAAA;AACjE,cAAA,KAAA,EAAA,GAAA,EAAA,MAAA,EAAA,UAAA,EAAA,aAAA,EAAA;UAAM,KAAA,GAAc,SAAA,CAAA;UACd,MAAA,GAAc;UACd,UAAA,GAAc;AACd;UAAA,KAAA,YAAA;YACE,MAAM,CAAC,IAAP,CAAY,KAAZ;YACA,UAAU,CAAC,IAAX,CAAgB,KAAK,CAAC,KAAtB;UAFF;UAGA,aAAA,GAAgB,KAAK,CAAC,MAAM,CAAC,IAAb,CAAkB,MAAlB;;YAChB,CAAC,CAAE,EAAH,CAAM,MAAN,EAAc,aAAd;;;YACA,CAAC,CAAE,EAAH,CAAQ,KAAK,CAAC,MAAM,CAAC,WAAb,CAA4B,MAAM,CAAC,EAAP,CAAW,CAAX,CAA5B,EAA8C,MAAM,CAAC,EAAP,CAAU,CAAC,CAAX,CAA9C,CAAR,EAAwE,IAAxE;;;YACA,CAAC,CAAE,EAAH,CAAQ,KAAK,CAAC,MAAM,CAAC,WAAb,CAA4B,MAAM,CAAC,EAAP,CAAU,CAAC,CAAX,CAA5B,EAA8C,MAAM,CAAC,EAAP,CAAW,CAAX,CAA9C,CAAR,EAAwE,KAAxE;;;YACA,CAAC,CAAE,EAAH,CAAQ,KAAK,CAAC,MAAM,CAAC,GAAb,CAA4B,MAAM,CAAC,EAAP,CAAW,CAAX,CAA5B,EAA8C,MAAM,CAAC,EAAP,CAAU,CAAC,CAAX,CAA9C,CAAR,EAAwE,CAAC,CAAzE;;;YACA,CAAC,CAAE,EAAH,CAAQ,KAAK,CAAC,MAAM,CAAC,GAAb,CAA4B,MAAM,CAAC,EAAP,CAAU,CAAC,CAAX,CAA5B,EAA8C,MAAM,CAAC,EAAP,CAAW,CAAX,CAA9C,CAAR,EAAwE,CAAC,CAAzE;;;YACA,CAAC,CAAE,EAAH,CAAQ,KAAK,CAAC,MAAM,CAAC,GAAb,CAA4B,MAAM,CAAC,EAAP,CAAU,CAAC,CAAX,CAA5B,EAA8C,MAAM,CAAC,EAAP,CAAU,CAAC,CAAX,CAA9C,CAAR,EAAyE,CAAzE;;;YACA,CAAC,CAAE,EAAH,CAAQ,KAAK,CAAC,MAAM,CAAC,GAAb,CAA4B,MAAM,CAAC,EAAP,CAAW,CAAX,CAA5B,EAA8C,MAAM,CAAC,EAAP,CAAW,CAAX,CAA9C,CAAR,EAAyE,CAAzE;WAbN;;;iBAgBM,OAAA,CAAQ,UAAU,CAAC,IAAX,CAAgB,GAAhB,CAAR;QAjB2D,CAAZ;MAAV,CAAjC;IADR;;MAoBA;;AACA,WAAO;EA5CS,EA5ClB;;;EA6FA,IAAG,OAAO,CAAC,IAAR,KAAgB,MAAnB;IAAkC,CAAA,CAAA,CAAA,GAAA;aAChC,IAAA,CAAK,IAAL;IADgC,CAAA,IAAlC;;AA7FA",
  "sourcesContent": [
    "\n'use strict'\n\n\n############################################################################################################\nGUY                       = require 'guy'\n{ alert\n  debug\n  help\n  info\n  plain\n  praise\n  urge\n  warn\n  whisper }               = GUY.trm.get_loggers 'INTERTEXT-LEXER/TESTS/SORTER'\n{ rpr\n  inspect\n  echo\n  log     }               = GUY.trm\n#...........................................................................................................\ntest                      = require '../../../apps/guy-test'\nPATH                      = require 'path'\n# FS                        = require 'fs'\ntypes                     = new ( require 'intertype' ).Intertype\n{ isa\n  equals\n  type_of\n  validate\n  validate_list_of }      = types.export()\nSQL                       = String.raw\nguy                       = require '../../../apps/guy'\nH                         = require '../../../lib/helpers'\nH2                        = require './helpers'\nafter                     = ( dts, f  ) => new Promise ( resolve ) -> setTimeout ( -> resolve f() ), dts * 1000\n{ DATOM }                 = require '../../../apps/datom'\n{ new_datom\n  lets\n  stamp     }             = DATOM\n\n\n\n\n#===========================================================================================================\n# TESTS\n#-----------------------------------------------------------------------------------------------------------\n@token_ordering = ( T, done ) ->\n  { Pipeline,         \\\n    $,\n    transforms,     } = require '../../../apps/moonriver'\n  { Interlex\n    compose  }        = require '../../../apps/intertext-lexer'\n  first               = Symbol 'first'\n  last                = Symbol 'last'\n  #.........................................................................................................\n  new_lexer = ( mode = 'plain' ) ->\n    lexer   = new Interlex { linewise: true, }\n    #.......................................................................................................\n    lexer.add_lexeme { mode, tid: 'star',   pattern: /[*]/u, }\n    lexer.add_lexeme { mode, tid: 'nl',     pattern: /$/u, }\n    lexer.add_lexeme { mode, tid: 'letter', pattern: /[^*]/u, }\n    #.......................................................................................................\n    return lexer\n  #.........................................................................................................\n  probes_and_matchers = [\n    [ '*abc*', '*,a,b,c,*,', null ]\n    [ '*abc*\\ndef', '*,a,b,c,*,,d,e,f,', null ]\n    ]\n  #.........................................................................................................\n  for [ probe, matcher, error, ] in probes_and_matchers\n    await T.perform probe, matcher, error, -> return new Promise ( resolve, reject ) ->\n      lexer       = new_lexer()\n      result      = []\n      result_rpr  = []\n      for token from lexer.walk probe\n        result.push token\n        result_rpr.push token.value\n      result_sorted = lexer.sorter.sort result\n      T?.eq result, result_sorted\n      T?.eq ( lexer.sorter.ordering_is  ( result.at  0 ), ( result.at -1 ) ), true\n      T?.eq ( lexer.sorter.ordering_is  ( result.at -1 ), ( result.at  0 ) ), false\n      T?.eq ( lexer.sorter.cmp          ( result.at  0 ), ( result.at -1 ) ), -1\n      T?.eq ( lexer.sorter.cmp          ( result.at -1 ), ( result.at  0 ) ), +1\n      T?.eq ( lexer.sorter.cmp          ( result.at -1 ), ( result.at -1 ) ),  0\n      T?.eq ( lexer.sorter.cmp          ( result.at  0 ), ( result.at  0 ) ),  0\n      # H.tabulate \"#{rpr probe} -> #{rpr result_rpr}\", result_sorted\n      # H.tabulate \"#{rpr probe} -> #{rpr result_rpr}\", result # unless result_rpr is matcher\n      resolve result_rpr.join ','\n  #.........................................................................................................\n  done?()\n  return null\n\n\n\n############################################################################################################\nif require.main is module then do =>\n  test @\n\n\n"
  ]
}