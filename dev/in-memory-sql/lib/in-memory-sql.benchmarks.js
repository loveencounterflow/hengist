(function() {
  'use strict';
  var BM, CND, DATA, FS, PATH, alert, badge, data_cache, debug, echo, gcfg, help, info, jr, log, rpr, show_result, test, urge, warn, whisper;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'IN-MEMORY-SQL';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  PATH = require('path');

  FS = require('fs');

  DATA = require('../../../lib/data-providers-nocache');

  test = require('guy-test');

  ({jr} = CND);

  BM = require('../../../lib/benchmarks');

  data_cache = null;

  gcfg = {
    verbose: false
  };

  //-----------------------------------------------------------------------------------------------------------
  show_result = function(name, result) {
    info('-----------------------------------------------');
    urge(name);
    whisper(result);
    info('-----------------------------------------------');
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.get_data = function(cfg) {
    var DATOM, texts;
    if (data_cache != null) {
      return data_cache;
    }
    whisper("retrieving test data...");
    DATOM = require('../../../apps/datom');
    //.........................................................................................................
    texts = DATA.get_words(cfg.word_count);
    //.........................................................................................................
    data_cache = {texts};
    data_cache = DATOM.freeze(data_cache);
    whisper("...done");
    return data_cache;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.pgmem = function(cfg) {
    return new Promise((resolve) => {
      var PGM, count, data, db, table;
      db = (require('pg-mem')).newDb();
      PGM = require('pg-mem');
      data = this.get_data(cfg);
      count = 0;
      //.........................................................................................................
      /* PGM data types:
       array, bigint, bool, box, bytea, circlecitext, date, decimal, float, inet, integer, interval, json,
       jsonb, line, lseg, null, path, point, polygon, record, regclass, regtype, text, time, timestamp,
       timestampz, uuid */
      // generate_series = ( first_n, last_n ) => 42
      // generate_series_des = {
      //   name:             'generate_series',
      //   args:             [ PGM.DataType.integer, PGM.DataType.integer, ],
      //   returns:          PGM.DataType.integer,
      //   implementation:   generate_series, }
      // db.public.registerFunction generate_series
      // debug db.public.many """select * from generate_series( 1, 10 ) as n;"""
      //.........................................................................................................
      db.public.none(`create table test(
  id    integer generated by default as identity primary key,
  nr    integer not null,
  text  text );`);
      table = db.public.getTable('test');
      //.........................................................................................................
      resolve(() => {
        return new Promise((resolve) => {
          var i, len, nr, ref, result, text;
          nr = 0;
          ref = data.texts;
          for (i = 0, len = ref.length; i < len; i++) {
            text = ref[i];
            nr++;
            table.insert({nr, text});
          }
          result = db.public.many(`select * from test order by text;`);
          count += result.length;
          if (gcfg.verbose) {
            show_result('pgmem', result);
          }
          // db.close()
          return resolve(count);
        });
      });
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._bettersqlite3 = function(cfg, db_path, do_backup = false) {
    return new Promise((resolve) => {
      var Db, count, data, db, db_cfg, insert, retrieve;
      Db = require('better-sqlite3');
      // db_cfg        = { verbose: ( CND.get_logger 'whisper', '^33365^ SQLite3' ), }
      db_cfg = null;
      db = new Db(db_path, db_cfg);
      data = this.get_data(cfg);
      count = 0;
      //.........................................................................................................
      // db.unsafeMode true
      // db.pragma 'cache_size = 32000'
      db.pragma('synchronous = OFF'); // makes file-based DBs much faster
      //.........................................................................................................
      db.exec(`drop table if exists test;`);
      db.exec(`create table test(
  id    integer primary key,
  nr    integer not null,
  text  text );`);
      // debug '^22233^', db.exec """insert into test ( nr, text ) values ( 1, '2' );"""
      insert = db.prepare(`insert into test ( nr, text ) values ( ?, ? );`);
      retrieve = db.prepare(`select * from test order by text;`);
      //.........................................................................................................
      resolve(() => {
        return new Promise(async(resolve) => {
          var i, len, nr, ref, result, text;
          nr = 0;
          ref = data.texts;
          for (i = 0, len = ref.length; i < len; i++) {
            text = ref[i];
            nr++;
            insert.run([nr, text]);
          }
          result = retrieve.all();
          count += result.length;
          if (gcfg.verbose) {
            show_result('bettersqlite3', result);
          }
          if (do_backup) {
            await db.backup(`/tmp/hengist-in-memory-sql.benchmarks.backup-${Date.now()}.db`);
          }
          db.close();
          return resolve(count);
        });
      });
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.bettersqlite3_memory = (cfg) => {
    return this._bettersqlite3(cfg, ':memory:');
  };

  this.bettersqlite3_backup = (cfg) => {
    return this._bettersqlite3(cfg, ':memory:', true);
  };

  this.bettersqlite3_file = (cfg) => {
    return this._bettersqlite3(cfg, '/tmp/hengist-in-memory-sql.benchmarks.db');
  };

  //-----------------------------------------------------------------------------------------------------------
  this.bettersqlite3_memory_noprepare = function(cfg) {
    return new Promise((resolve) => {
      var Db, count, data, db, db_cfg;
      Db = require('better-sqlite3');
      // db_cfg        = { verbose: ( CND.get_logger 'whisper', '^33365^ SQLite3' ), }
      db_cfg = null;
      db = new Db(':memory:', db_cfg);
      data = this.get_data(cfg);
      count = 0;
      //.........................................................................................................
      // db.unsafeMode true
      // db.pragma 'cache_size = 32000'
      db.pragma('synchronous = OFF'); // makes file-based DBs much faster
      //.........................................................................................................
      db.exec(`drop table if exists test;`);
      db.exec(`create table test(
  id    integer primary key,
  nr    integer not null,
  text  text );`);
      //.........................................................................................................
      resolve(() => {
        return new Promise((resolve) => {
          var i, insert, len, nr, ref, result, retrieve, text;
          nr = 0;
          ref = data.texts;
          for (i = 0, len = ref.length; i < len; i++) {
            text = ref[i];
            nr++;
            insert = db.prepare(`insert into test ( nr, text ) values ( ?, ? );`);
            insert.run([nr, text]);
          }
          retrieve = db.prepare(`select * from test order by text;`);
          result = retrieve.all();
          count += result.length;
          if (gcfg.verbose) {
            show_result('bettersqlite3', result);
          }
          db.close();
          return resolve(count);
        });
      });
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._bettersqlite3_memory_icql = function(cfg, icql_version) {
    return new Promise((resolve) => {
      var Db, ICQL, count, data, db, icql_cfg, icql_path;
      Db = require('better-sqlite3');
      icql_path = PATH.resolve(PATH.join(__dirname, '../demo-frp.icql'));
      ICQL = require((function() {
        switch (icql_version) {
          case 'icql_latest':
            return '../../../apps/icql';
          case 'icql515':
            return 'icql515';
          default:
            throw new Error(`^45458^ unknown icql_version: ${rpr(icql_version)}`);
        }
      })());
      icql_cfg = {
        connector: Db,
        db_path: ':memory:',
        icql_path: icql_path
      };
      db = ICQL.bind(icql_cfg);
      db.create_table_test();
      data = this.get_data(cfg);
      count = 0;
      //.........................................................................................................
      resolve(() => {
        return new Promise((resolve) => {
          var i, len, nr, ref, result, text;
          nr = 0;
          ref = data.texts;
          for (i = 0, len = ref.length; i < len; i++) {
            text = ref[i];
            nr++;
            db.insert_text({nr, text});
          }
          result = db.$.all_rows(db.get_all_texts());
          count += result.length;
          if (gcfg.verbose) {
            show_result('bettersqlite3_memory_icql', result);
          }
          db.$.db.close();
          return resolve(count);
        });
      });
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.bettersqlite3_memory_icql515 = function(cfg) {
    return this._bettersqlite3_memory_icql(cfg, 'icql515');
  };

  this.bettersqlite3_memory_icql_latest = function(cfg) {
    return this._bettersqlite3_memory_icql(cfg, 'icql_latest');
  };

  //-----------------------------------------------------------------------------------------------------------
  this.sqljs = function(cfg) {
    return new Promise(async(resolve) => {
      var DB/* NOTE this is the default import */, count, data, db, initSqlJs, insert, retrieve;
      // initSqlJs            = require 'sql.js/dist/sql-asm-debug.js'
      // initSqlJs            = require 'sql.js/dist/sql-asm-memory-growth.js'
      // initSqlJs            = require 'sql.js/dist/sql-asm.js'
      // initSqlJs            = require 'sql.js/dist/sql-wasm-debug.js'
      initSqlJs = require('sql.js/dist/sql-wasm.js');
      DB = (await initSqlJs());
      // debug ( k for k of require 'sql.js')
      // debug ( k for k of DB)
      // debug DB
      // debug ( k for k of DB.default)
      // debug ( k for k of DB.default.default)
      db = new DB.Database();
      data = this.get_data(cfg);
      count = 0;
      //.........................................................................................................
      db.run(`create table test(
  id    integer primary key,
  nr    integer not null,
  text  text );`);
      // debug '^22233^', db.exec """insert into test ( nr, text ) values ( 1, '2' );"""
      insert = db.prepare(`insert into test ( nr, text ) values ( ?, ? );`);
      retrieve = db.prepare(`select * from test order by text;`);
      //.........................................................................................................
      resolve(() => {
        return new Promise((resolve) => {
          var i, len, nr, ref, result, text;
          nr = 0;
          ref = data.texts;
          for (i = 0, len = ref.length; i < len; i++) {
            text = ref[i];
            nr++;
            /* TAINT use prepared statement */
            // db.run """insert into test ( nr, text ) values ( ?, ? );""", [ nr, text, ]
            insert.bind([nr, text]);
            while (insert.step()) {
              insert.get();
            }
          }
          // debug (k for k of retrieve)
          // retrieve.bind(); result = []; result.push retrieve.getAsObject()  while retrieve.step()
          result = [];
          db.each(`select * from test order by text;`, [], function(row) {
            return result.push(row);
          });
          // retrieve.bind(); result = []; result.push retrieve.get()          while retrieve.step()
          count += result.length;
          if (gcfg.verbose) {
            show_result('sqljs', result);
          }
          db.close();
          return resolve(count);
        });
      });
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.porsagerpostgres = function(cfg) {
    return new Promise(async(resolve) => {
      var count, data, postgres, sql;
      postgres = require('postgres');
      sql = postgres('postgres://interplot@localhost:5432/interplot');
      count = 0;
      data = this.get_data(cfg);
      //.........................................................................................................
      // await sql"""begin transaction;"""
      await sql`drop table if exists test cascade;`;
      await sql`create table test(
  id    integer generated by default as identity primary key,
  nr    integer not null,
  text  text );`;
      //.........................................................................................................
      resolve(() => {
        return new Promise(async(resolve) => {
          var nr, result;
          // { rows }     = await sql"select * from MIRAGE.mirror order by dsk, dsnr, linenr limit 10;"
          nr = 0;
          await sql.begin(async(sql) => {
            var i, len, ref, results, text;
            ref = data.texts;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
              text = ref[i];
              nr++;
              results.push((await sql`insert into test ( nr, text ) values ( ${nr}, ${text} );`));
            }
            return results;
          });
          result = (await sql`select * from test order by text;`);
          if (gcfg.verbose) {
            show_result('bettersqlite3', result);
          }
          count += result.length;
          await sql.end({
            timeout: 0
          });
          return resolve(count);
        });
      });
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.briancpg = function(cfg) {
    return new Promise(async(resolve) => {
      var count, data, db, db_cfg, pool;
      db_cfg = {
        database: 'interplot',
        user: 'interplot',
        port: 5432
      };
      pool = new (require('pg')).Pool(db_cfg);
      db = (await pool.connect());
      count = 0;
      data = this.get_data(cfg);
      //.........................................................................................................
      // await sql"""begin transaction;"""
      await db.query(`drop table if exists test cascade;`);
      await db.query(`create table test(
  id    integer generated by default as identity primary key,
  nr    integer not null,
  text  text );`);
      //.........................................................................................................
      resolve(() => {
        return new Promise(async(resolve) => {
          var i, len, nr, q, ref, result, text;
          try {
            await db.query('begin');
            q = {
              text: `insert into test ( nr, text ) values ( $1, $2 );`,
              rowMode: 'array'/* TAINT does not seem to work */,
              values: [0, '']
            };
            nr = 0;
            ref = data.texts;
            for (i = 0, len = ref.length; i < len; i++) {
              text = ref[i];
              nr++;
              q.values = [nr, text];
              await db.query(q);
            }
            result = (await db.query(`select * from test order by text;`));
            await db.query('rollback');
            if (gcfg.verbose) {
              show_result('briancpg', result.rows);
            }
            count += result.rows.length;
            await resolve(count);
          } finally {
            db.release();
            pool.end();
          }
          return resolve(1);
        });
      });
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.run_benchmarks = async function() {
    var _, bench, cfg, i, j, len, ref, ref1, repetitions, test_name, test_names;
    gcfg.verbose = true;
    gcfg.verbose = false;
    bench = BM.new_benchmarks();
    cfg = {
      word_count: 1000
    };
    repetitions = 3;
    test_names = ['bettersqlite3_memory', 'bettersqlite3_memory_icql_latest', 'bettersqlite3_memory_icql515'];
    if (global.gc != null) {
      // 'bettersqlite3_memory_noprepare'
      // 'bettersqlite3_backup'
      // 'bettersqlite3_file'
      // 'pgmem'
      // 'sqljs'
      // 'porsagerpostgres'
      // 'briancpg'
      global.gc();
    }
    data_cache = null;
    for (_ = i = 1, ref = repetitions; (1 <= ref ? i <= ref : i >= ref); _ = 1 <= ref ? ++i : --i) {
      whisper('-'.repeat(108));
      ref1 = CND.shuffle(test_names);
      for (j = 0, len = ref1.length; j < len; j++) {
        test_name = ref1[j];
        if (global.gc != null) {
          global.gc();
        }
        await BM.benchmark(bench, cfg, false, this, test_name);
      }
    }
    return BM.show_totals(bench);
  };

  //###########################################################################################################
  if (require.main === module) {
    (async() => {
      return (await this.run_benchmarks());
    })();
  }

}).call(this);

//# sourceMappingURL=in-memory-sql.benchmarks.js.map