

'use strict'

############################################################################################################
CND                       = require 'cnd'
rpr                       = CND.rpr
badge                     = 'IN-MEMORY-SQL'
log                       = CND.get_logger 'plain',     badge
info                      = CND.get_logger 'info',      badge
whisper                   = CND.get_logger 'whisper',   badge
alert                     = CND.get_logger 'alert',     badge
debug                     = CND.get_logger 'debug',     badge
warn                      = CND.get_logger 'warn',      badge
help                      = CND.get_logger 'help',      badge
urge                      = CND.get_logger 'urge',      badge
echo                      = CND.echo.bind CND
#...........................................................................................................
PATH                      = require 'path'
FS                        = require 'fs'
DATA                      = require '../../../lib/data-providers-nocache'
test                      = require 'guy-test'
{ jr }                    = CND
BM                        = require '../../../lib/benchmarks'
data_cache                = null
gcfg                      = { verbose: false, }

#-----------------------------------------------------------------------------------------------------------
try_to_remove_file = ( path ) ->
  try FS.unlinkSync path catch error
    return if error.code is 'ENOENT'
    throw error
  return null

#-----------------------------------------------------------------------------------------------------------
show_result = ( name, result ) ->
  info '-----------------------------------------------'
  urge name
  whisper result
  info '-----------------------------------------------'
  return null

#-----------------------------------------------------------------------------------------------------------
@get_data = ( cfg ) ->
  return data_cache if data_cache?
  whisper "retrieving test data..."
  DATOM = require '../../../apps/datom'
  #.........................................................................................................
  texts       = DATA.get_words cfg.word_count
  #.........................................................................................................
  data_cache  = { texts, }
  data_cache  = DATOM.freeze data_cache
  whisper "...done"
  return data_cache

#-----------------------------------------------------------------------------------------------------------
@pgmem = ( cfg ) -> new Promise ( resolve ) =>
  db            = ( require 'pg-mem' ).newDb()
  PGM           = require 'pg-mem'
  data          = @get_data cfg
  count         = 0
  #.........................................................................................................
  ### PGM data types:
  array, bigint, bool, box, bytea, circlecitext, date, decimal, float, inet, integer, interval, json,
  jsonb, line, lseg, null, path, point, polygon, record, regclass, regtype, text, time, timestamp,
  timestampz, uuid ###
  # generate_series = ( first_n, last_n ) => 42
  # generate_series_des = {
  #   name:             'generate_series',
  #   args:             [ PGM.DataType.integer, PGM.DataType.integer, ],
  #   returns:          PGM.DataType.integer,
  #   implementation:   generate_series, }
  # db.public.registerFunction generate_series
  # debug db.public.many """select * from generate_series( 1, 10 ) as n;"""
  #.........................................................................................................
  db.public.none """
    create table test(
      id    integer generated by default as identity primary key,
      nr    integer not null,
      text  text );"""
  table = db.public.getTable 'test'
  #.........................................................................................................
  resolve => new Promise ( resolve ) =>
    nr      = 0
    for text in data.texts
      nr++
      table.insert { nr, text, }
    result  = db.public.many """select * from test order by text;"""
    count  += result.length
    show_result 'pgmem', result if gcfg.verbose
    # db.close()
    resolve count
  return null

#-----------------------------------------------------------------------------------------------------------
@bettersqlite3_membacked = ( cfg, use_membacked = true ) -> new Promise ( resolve ) =>
  Db            = require 'better-sqlite3'
  # db_cfg        = { verbose: ( CND.get_logger 'whisper', '^33365^ SQLite3' ), }
  #.........................................................................................................
  do populate_file = =>
    db_cfg        = null
    db_path       = "/tmp/hengist-in-memory-sql.benchmarks.membacked.db"
    filedb        = new Db db_path, db_cfg
    data          = @get_data cfg
    count         = 0
    #.........................................................................................................
    # filedb.unsafeMode true
    # filedb.pragma 'cache_size = 32000'
    filedb.pragma 'synchronous = OFF' # makes file-based DBs much faster
    #.........................................................................................................
    filedb.exec """drop table if exists test;"""
    filedb.exec """
      create table test(
        id    integer primary key,
        nr    integer not null,
        text  text );"""
    # debug '^22233^', filedb.exec """insert into test ( nr, text ) values ( 1, '2' );"""
    insert        = filedb.prepare """insert into test ( nr, text ) values ( ?, ? );"""
    retrieve      = filedb.prepare """select * from test order by text;"""
    nr      = 0
    for text in data.texts
      nr++
      insert.run [ nr, text, ]
    filedb.backup ':memory:'
    return null
  #.........................................................................................................
  resolve => new Promise ( resolve ) =>
    result  = retrieve.all()
    count  += result.length
    show_result 'bettersqlite3', result if gcfg.verbose
    if do_backup
      await db.backup ':memory:'
    db.close()
    resolve count
  return null

#-----------------------------------------------------------------------------------------------------------
@_bettersqlite3 = ( cfg ) -> new Promise ( resolve ) =>
  Db            = require 'better-sqlite3'
  # db_cfg        = { verbose: ( CND.get_logger 'whisper', '^33365^ SQLite3' ), }
  defaults      = { do_backup: false, pragmas: [], }
  cfg           = { defaults..., cfg..., }
  db_cfg        = null
  try_to_remove_file cfg.db_path if cfg.db_path isnt ':memory:'
  db            = new Db cfg.db_path, db_cfg
  data          = @get_data cfg
  count         = 0
  #.........................................................................................................
  # db.unsafeMode true
  # db.pragma 'cache_size = 32000'
  db.pragma 'synchronous = OFF' # makes file-based DBs much faster
  for pragma in cfg.pragmas
    db.pragma pragma
  #.........................................................................................................
  # db.exec """drop table if exists test;"""
  db.exec """
    create table test(
      id    integer primary key,
      nr    integer not null,
      text  text );"""
  # debug '^22233^', db.exec """insert into test ( nr, text ) values ( 1, '2' );"""
  insert        = db.prepare """insert into test ( nr, text ) values ( ?, ? );"""
  retrieve      = db.prepare """select * from test order by text;"""
  retrieve.raw true
  #.........................................................................................................
  resolve => new Promise ( resolve ) =>
    nr      = 0
    # db.transaction =>
    for text in data.texts
      nr++
      insert.run [ nr, text, ]
    result  = retrieve.all()
    count  += result.length
    show_result 'bettersqlite3', result if gcfg.verbose
    if cfg.do_backup
      await db.backup "/tmp/hengist-in-memory-sql.benchmarks.backup-#{Date.now()}.db"
    db.close()
    resolve count
  return null

#-----------------------------------------------------------------------------------------------------------
@bettersqlite3_memory = ( cfg ) => @_bettersqlite3 { cfg..., db_path: ':memory:', }
@bettersqlite3_backup = ( cfg ) => @_bettersqlite3 { cfg..., db_path: ':memory:', do_backup: true, }
@bettersqlite3_file   = ( cfg ) => @_bettersqlite3 { cfg..., db_path: '/tmp/hengist-in-memory-sql.benchmarks.db', }
#...........................................................................................................
@bettersqlite3_jmdel    = ( cfg ) => @_bettersqlite3 { cfg..., db_path: '/tmp/hengist-in-memory-sql.jmdel.benchmarks.db',   pragmas: [ 'journal_mode = DELETE;', ] }
@bettersqlite3_jmtrunc  = ( cfg ) => @_bettersqlite3 { cfg..., db_path: '/tmp/hengist-in-memory-sql.jmtrunc.benchmarks.db', pragmas: [ 'journal_mode = TRUNCATE;', ] }
@bettersqlite3_jmpers   = ( cfg ) => @_bettersqlite3 { cfg..., db_path: '/tmp/hengist-in-memory-sql.jmpers.benchmarks.db',  pragmas: [ 'journal_mode = PERSIST;', ] }
@bettersqlite3_jmmem    = ( cfg ) => @_bettersqlite3 { cfg..., db_path: '/tmp/hengist-in-memory-sql.jmmem.benchmarks.db',   pragmas: [ 'journal_mode = MEMORY;', ] }
@bettersqlite3_jmwal    = ( cfg ) => @_bettersqlite3 { cfg..., db_path: '/tmp/hengist-in-memory-sql.jmwal.benchmarks.db',   pragmas: [ 'journal_mode = WAL;', ] }
@bettersqlite3_jmoff    = ( cfg ) => @_bettersqlite3 { cfg..., db_path: '/tmp/hengist-in-memory-sql.jmoff.benchmarks.db',   pragmas: [ 'journal_mode = OFF;', ] }
@bettersqlite3_mmap     = ( cfg ) => @_bettersqlite3 { cfg..., db_path: '/tmp/hengist-in-memory-sql.mmap.benchmarks.db',    pragmas: [ 'mmap_size = 2147418112;', ] }
@bettersqlite3_tmpm     = ( cfg ) => @_bettersqlite3 { cfg..., db_path: '/tmp/hengist-in-memory-sql.tmpm.benchmarks.db',    pragmas: [ 'temp_store = MEMORY;', ] }
@bettersqlite3_thrds    = ( cfg ) => @_bettersqlite3 { cfg..., db_path: '/tmp/hengist-in-memory-sql.thrds.benchmarks.db',   pragmas: [ 'threads = 4;', ] }

#-----------------------------------------------------------------------------------------------------------
@bettersqlite3_memory_noprepare = ( cfg ) -> new Promise ( resolve ) =>
  Db            = require 'better-sqlite3'
  # db_cfg        = { verbose: ( CND.get_logger 'whisper', '^33365^ SQLite3' ), }
  db_cfg        = null
  db            = new Db ':memory:', db_cfg
  data          = @get_data cfg
  count         = 0
  #.........................................................................................................
  # db.unsafeMode true
  # db.pragma 'cache_size = 32000'
  db.pragma 'synchronous = OFF' # makes file-based DBs much faster
  #.........................................................................................................
  db.exec """drop table if exists test;"""
  db.exec """
    create table test(
      id    integer primary key,
      nr    integer not null,
      text  text );"""
  #.........................................................................................................
  resolve => new Promise ( resolve ) =>
    nr      = 0
    for text in data.texts
      nr++
      insert = db.prepare """insert into test ( nr, text ) values ( ?, ? );"""
      insert.run [ nr, text, ]
    retrieve  = db.prepare """select * from test order by text;"""
    result    = retrieve.all()
    count    += result.length
    show_result 'bettersqlite3', result if gcfg.verbose
    db.close()
    resolve count
  return null

#-----------------------------------------------------------------------------------------------------------
@_bettersqlite3_memory_icql = ( cfg, icql_version ) -> new Promise ( resolve ) =>
  Db            = require 'better-sqlite3'
  icql_path     = PATH.resolve PATH.join __dirname, '../demo-frp.icql'
  ICQL          = require switch icql_version
    when 'icql_latest'  then '../../../apps/icql'
    when 'icql515'      then 'icql515'
    else throw new Error "^45458^ unknown icql_version: #{rpr icql_version}"
  icql_cfg =
    connector:    Db
    db_path:      ':memory:'
    icql_path:    icql_path
  db            = ICQL.bind icql_cfg
  db.create_table_text()
  data          = @get_data cfg
  count         = 0
  #.........................................................................................................
  resolve => new Promise ( resolve ) =>
    linenr = 0
    for line in data.texts
      linenr++
      db.insert_line { linenr, line, }
    result  = db.$.all_rows db.get_all_texts()
    count  += result.length
    show_result 'bettersqlite3_memory_icql', result if gcfg.verbose
    db.$.db.close()
    resolve count
  return null

#-----------------------------------------------------------------------------------------------------------
@bettersqlite3_memory_icql515     = ( cfg ) -> @_bettersqlite3_memory_icql cfg, 'icql515'
@bettersqlite3_memory_icql_latest = ( cfg ) -> @_bettersqlite3_memory_icql cfg, 'icql_latest'


#-----------------------------------------------------------------------------------------------------------
@sqljs = ( cfg ) -> new Promise ( resolve ) =>
  # initSqlJs            = require 'sql.js/dist/sql-asm-debug.js'
  # initSqlJs            = require 'sql.js/dist/sql-asm-memory-growth.js'
  # initSqlJs            = require 'sql.js/dist/sql-asm.js'
  # initSqlJs            = require 'sql.js/dist/sql-wasm-debug.js'
  initSqlJs   = require 'sql.js/dist/sql-wasm.js' ### NOTE this is the default import ###
  DB          = await initSqlJs()
  # debug ( k for k of require 'sql.js')
  # debug ( k for k of DB)
  # debug DB
  # debug ( k for k of DB.default)
  # debug ( k for k of DB.default.default)
  db            = new DB.Database()
  data          = @get_data cfg
  count         = 0
  #.........................................................................................................
  db.run """
    create table test(
      id    integer primary key,
      nr    integer not null,
      text  text );"""
  # debug '^22233^', db.exec """insert into test ( nr, text ) values ( 1, '2' );"""
  insert        = db.prepare """insert into test ( nr, text ) values ( ?, ? );"""
  retrieve      = db.prepare """select * from test order by text;"""
  #.........................................................................................................
  resolve => new Promise ( resolve ) =>
    nr      = 0
    for text in data.texts
      nr++
      ### TAINT use prepared statement ###
      # db.run """insert into test ( nr, text ) values ( ?, ? );""", [ nr, text, ]
      insert.bind [ nr, text, ]
      insert.get() while insert.step()
    # debug (k for k of retrieve)
    # retrieve.bind(); result = []; result.push retrieve.getAsObject()  while retrieve.step()
    result = []; db.each """select * from test order by text;""", [], ( row ) -> result.push row
    # retrieve.bind(); result = []; result.push retrieve.get()          while retrieve.step()
    count  += result.length
    show_result 'sqljs', result if gcfg.verbose
    db.close()
    resolve count
  return null

#-----------------------------------------------------------------------------------------------------------
@porsagerpostgres = ( cfg ) -> new Promise ( resolve ) =>
  postgres      = require 'postgres'
  sql           = postgres 'postgres://interplot@localhost:5432/interplot'
  count         = 0
  data          = @get_data cfg
  #.........................................................................................................
    # await sql"""begin transaction;"""
  await sql"""drop table if exists test cascade;"""
  await sql"""
    create table test(
      id    integer generated by default as identity primary key,
      nr    integer not null,
      text  text );"""
  #.........................................................................................................
  resolve => new Promise ( resolve ) =>
    # { rows }     = await sql"select * from MIRAGE.mirror order by dsk, dsnr, linenr limit 10;"
    nr      = 0
    await sql.begin ( sql ) =>
      for text in data.texts
        nr++
        await sql"""insert into test ( nr, text ) values ( #{nr}, #{text} );"""
    result  = await sql"""select * from test order by text;"""
    show_result 'bettersqlite3', result if gcfg.verbose
    count  += result.length
    await sql.end { timeout: 0 }
    resolve count
  return null

#-----------------------------------------------------------------------------------------------------------
@briancpg = ( cfg ) -> new Promise ( resolve ) =>
  db_cfg        = { database: 'interplot', user: 'interplot', port: 5432, }
  pool          = new ( require 'pg' ).Pool db_cfg
  db            = await pool.connect()
  count         = 0
  data          = @get_data cfg
  #.........................................................................................................
    # await sql"""begin transaction;"""
  await db.query """drop table if exists test cascade;"""
  await db.query """
    create table test(
      id    integer generated by default as identity primary key,
      nr    integer not null,
      text  text );"""
  #.........................................................................................................
  resolve => new Promise ( resolve ) =>
    try
      await db.query 'begin'
      q =
        text:     """insert into test ( nr, text ) values ( $1, $2 );"""
        rowMode:  'array' ### TAINT does not seem to work ###
        values:   [ 0, '', ]
      nr = 0
      for text in data.texts
        nr++
        q.values = [ nr, text, ]
        await db.query q
      result  = await db.query """select * from test order by text;"""
      await db.query 'rollback'
      show_result 'briancpg', result.rows if gcfg.verbose
      count  += result.rows.length
      await resolve count
    finally
      db.release()
      pool.end()
    resolve 1
  return null


#-----------------------------------------------------------------------------------------------------------
@run_benchmarks = ->
  gcfg.verbose  = true
  gcfg.verbose  = false
  bench         = BM.new_benchmarks()
  cfg           = { word_count: 1000, }
  repetitions   = 3
  test_names    = [
    'bettersqlite3_jmdel'
    'bettersqlite3_jmtrunc'
    'bettersqlite3_jmpers'
    'bettersqlite3_jmmem'
    'bettersqlite3_jmwal'
    'bettersqlite3_jmoff'
    'bettersqlite3_mmap'
    'bettersqlite3_memory'
    'bettersqlite3_memory_icql_latest'
    'bettersqlite3_memory_icql515'
    'bettersqlite3_backup'
    'bettersqlite3_file'
    'bettersqlite3_memory_noprepare'
    'bettersqlite3_tmpm'
    'bettersqlite3_thrds'
    # 'pgmem'
    # 'sqljs'
    # 'porsagerpostgres'
    # 'briancpg'
    ]
  global.gc() if global.gc?
  data_cache = null
  for _ in [ 1 .. repetitions ]
    whisper '-'.repeat 108
    for test_name in CND.shuffle test_names
      global.gc() if global.gc?
      await BM.benchmark bench, cfg, false, @, test_name
  BM.show_totals bench


############################################################################################################
if require.main is module then do =>
  await @run_benchmarks()
