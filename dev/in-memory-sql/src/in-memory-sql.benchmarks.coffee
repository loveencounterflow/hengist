

'use strict'

############################################################################################################
CND                       = require 'cnd'
rpr                       = CND.rpr
badge                     = 'IN-MEMORY-SQL'
log                       = CND.get_logger 'plain',     badge
info                      = CND.get_logger 'info',      badge
whisper                   = CND.get_logger 'whisper',   badge
alert                     = CND.get_logger 'alert',     badge
debug                     = CND.get_logger 'debug',     badge
warn                      = CND.get_logger 'warn',      badge
help                      = CND.get_logger 'help',      badge
urge                      = CND.get_logger 'urge',      badge
echo                      = CND.echo.bind CND
#...........................................................................................................
PATH                      = require 'path'
FS                        = require 'fs'
DATA                      = require '../../../lib/data-providers-nocache'
test                      = require 'guy-test'
{ jr }                    = CND
BM                        = require '../../../lib/benchmarks'
data_cache                = null
gcfg                      = { verbose: false, }

#-----------------------------------------------------------------------------------------------------------
show_result = ( name, result ) ->
  info '-----------------------------------------------'
  urge name
  whisper result
  info '-----------------------------------------------'
  return null

#-----------------------------------------------------------------------------------------------------------
@get_data = ( cfg ) ->
  return data_cache if data_cache?
  whisper "retrieving test data..."
  DATOM = require '../../../apps/datom'
  #.........................................................................................................
  texts       = DATA.get_words cfg.word_count
  #.........................................................................................................
  data_cache  = { texts, }
  data_cache  = DATOM.freeze data_cache
  whisper "...done"
  return data_cache

#-----------------------------------------------------------------------------------------------------------
@pgmem = ( cfg ) -> new Promise ( resolve ) =>
  db            = ( require 'pg-mem' ).newDb()
  PGM           = require 'pg-mem'
  data          = @get_data cfg
  count         = 0
  #.........................................................................................................
  ### PGM data types:
  array, bigint, bool, box, bytea, circlecitext, date, decimal, float, inet, integer, interval, json,
  jsonb, line, lseg, null, path, point, polygon, record, regclass, regtype, text, time, timestamp,
  timestampz, uuid ###
  # generate_series = ( first_n, last_n ) => 42
  # generate_series_des = {
  #   name:             'generate_series',
  #   args:             [ PGM.DataType.integer, PGM.DataType.integer, ],
  #   returns:          PGM.DataType.integer,
  #   implementation:   generate_series, }
  # db.public.registerFunction generate_series
  # debug db.public.many """select * from generate_series( 1, 10 ) as n;"""
  #.........................................................................................................
  db.public.none """
    create table test(
      id    integer generated by default as identity primary key,
      nr    integer not null,
      text  text );"""
  table = db.public.getTable 'test'
  #.........................................................................................................
  resolve => new Promise ( resolve ) =>
    nr      = 0
    for text in data.texts
      nr++
      table.insert { nr, text, }
    result  = db.public.many """select * from test order by text;"""
    count  += result.length
    show_result 'pgmem', result if gcfg.verbose
    resolve count
  return null

#-----------------------------------------------------------------------------------------------------------
@bettersqlite3 = ( cfg ) -> new Promise ( resolve ) =>
  Db            = require 'better-sqlite3'
  # db_cfg        = { verbose: ( CND.get_logger 'whisper', '^33365^ SQLite3' ), }
  db_cfg        = null
  db            = new Db ':memory:', db_cfg
  data          = @get_data cfg
  count         = 0
  #.........................................................................................................
  db.exec """
    create table test(
      id    integer primary key,
      nr    integer not null,
      text  text );"""
  # debug '^22233^', db.exec """insert into test ( nr, text ) values ( 1, '2' );"""
  insert        = db.prepare """insert into test ( nr, text ) values ( ?, ? );"""
  retrieve      = db.prepare """select * from test order by text;"""
  #.........................................................................................................
  resolve => new Promise ( resolve ) =>
    nr      = 0
    for text in data.texts
      nr++
      insert.run [ nr, text, ]
    result  = retrieve.all()
    count  += result.length
    show_result 'bettersqlite3', result if gcfg.verbose
    resolve count
  return null

#-----------------------------------------------------------------------------------------------------------
@sqljs = ( cfg ) -> new Promise ( resolve ) =>
  # DB            = require 'sql.js'
  # DB            = require 'sql.js/dist/sql-asm-debug.js'
  # DB            = require 'sql.js/dist/sql-asm-memory-growth.js'
  # DB            = require 'sql.js/dist/sql-asm.js'
  # DB            = require 'sql.js/dist/sql-wasm-debug.js'
  initSqlJs  = require 'sql.js/dist/sql-wasm.js' ### NOTE this is the default import ###
  DB = await initSqlJs()
  # debug ( k for k of require 'sql.js')
  # debug ( k for k of DB)
  # debug DB
  # debug ( k for k of DB.default)
  # debug ( k for k of DB.default.default)
  db            = new DB.Database()
  data          = @get_data cfg
  count         = 0
  #.........................................................................................................
  db.run """
    create table test(
      id    integer primary key,
      nr    integer not null,
      text  text );"""
  # debug '^22233^', db.exec """insert into test ( nr, text ) values ( 1, '2' );"""
  insert        = db.prepare """insert into test ( nr, text ) values ( ?, ? );"""
  retrieve      = db.prepare """select * from test order by text;"""
  #.........................................................................................................
  resolve => new Promise ( resolve ) =>
    nr      = 0
    for text in data.texts
      nr++
      ### TAINT use prepared statement ###
      # db.run """insert into test ( nr, text ) values ( ?, ? );""", [ nr, text, ]
      insert.bind [ nr, text, ]
      insert.get() while insert.step()
    # debug (k for k of retrieve)
    retrieve.bind(); result = []; result.push retrieve.getAsObject()  while retrieve.step()
    # retrieve.bind(); result = []; result.push retrieve.get()          while retrieve.step()
    count  += result.length
    show_result 'sqljs', result if gcfg.verbose
    resolve count
  return null


#-----------------------------------------------------------------------------------------------------------
@run_benchmarks = ->
  gcfg.verbose  = true
  gcfg.verbose  = false
  bench         = BM.new_benchmarks()
  cfg           = { word_count: 5000, }
  repetitions   = 1
  test_names    = [
    'pgmem'
    'bettersqlite3'
    'sqljs'
    ]
  global.gc() if global.gc?
  data_cache = null
  for _ in [ 1 .. repetitions ]
    whisper '-'.repeat 108
    for test_name in CND.shuffle test_names
      global.gc() if global.gc?
      await BM.benchmark bench, cfg, false, @, test_name
  BM.show_totals bench


############################################################################################################
if require.main is module then do =>
  await @run_benchmarks()



