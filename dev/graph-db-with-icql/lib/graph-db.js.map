{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/graph-db.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n\n'use strict'\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'GRAPHDB'\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\ninfo                      = CND.get_logger 'info',      badge\nurge                      = CND.get_logger 'urge',      badge\nhelp                      = CND.get_logger 'help',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\necho                      = CND.echo.bind CND\n{ Dba }                   = require '../../../apps/icql-dba'\ndef                       = Object.defineProperty\ntypes                     = require './types'\n{ SQL, I, L, X, }         = new ( require '../../../apps/icql-dba/lib/sql' ).Sql\njr                        = JSON.stringify\n\n\n#===========================================================================================================\nclass @Graphdb\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    # super()\n    def @, 'types', enumerable: false, value: types\n    @types.validate.gdb_constructor_cfg ( cfg = { @types.defaults.gdb_constructor_cfg..., cfg..., } )\n    @cfg        = cfg\n    { schema\n      ram\n      path    } = @cfg\n    def @, 'dba', enumerable: false, value: new Dba()\n    dba_cfg     = {}\n    dba_cfg.schema  = schema  if schema?\n    dba_cfg.ram     = ram     if ram?\n    dba_cfg.path    = path    if path?\n    @dba.open dba_cfg\n    @init_db()\n    @NG_init_db()\n    return undefined\n\n\n  #=========================================================================================================\n  # SCHEMA\n  #---------------------------------------------------------------------------------------------------------\n  init_db: () ->\n    ### TAINT edges are modelled as uniquely given by `( node_id_a, node_id_b )` with arbitrary data\n    attached, but could conceivably link two given nodes with any number of edges ###\n    sql = SQL\"\"\"\n      create table if not exists #{I @cfg.schema}.nodes (\n          body json,\n          id   text generated always as ( json_extract( body, '$.id' ) ) virtual not null unique\n        );\n      -- ...................................................................................................\n      create table if not exists #{I @cfg.schema}.edges (\n          source     text,\n          target     text,\n          properties json,\n        primary key ( source, target )\n        foreign key( source ) references nodes( id ),\n        foreign key( target ) references nodes( id )\n        );\n      -- ...................................................................................................\n      create index if not exists #{I @cfg.schema}.id_idx on nodes(id);\n      create index if not exists #{I @cfg.schema}.source_idx on edges(source);\n      create index if not exists #{I @cfg.schema}.target_idx on edges(target);\"\"\"\n    @dba.execute sql\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  NG_init_db: () ->\n    sql = SQL\"\"\"\n      -- ...................................................................................................\n      create table if not exists #{I @cfg.schema}.predicates (\n          p             text not null,\n          is_transitive boolean not null,\n        primary key ( p ) );\n      -- ...................................................................................................\n      create table if not exists #{I @cfg.schema}.phrases (\n          s       text not null,\n          p       text not null,\n          o       text not null,\n          a       json,\n          nr      integer not null,\n          ref     json    not null,\n          lck     boolean not null default false,\n        primary key ( s, p, o ),\n        foreign key ( p ) references predicates ( p ) );\n      \"\"\"\n    @dba.execute sql\n    #.......................................................................................................\n    @dba.function 'vnr_as_hollerith', { deterministic: true, varargs: false, }, ( vnr_json ) =>\n      return @vnr_as_hollerith JSON.parse vnr_json\n    @dba.function 'vnr_deepen', { deterministic: true, varargs: true, }, ( vnr_json, extra = 0 ) =>\n      # debug '^8776^', [ vnr_json, extra, ]\n      return JSON.stringify @vnr_deepen ( JSON.parse vnr_json ), extra\n    @dba.function 'ref_push', { deterministic: true, varargs: false, }, ( ref1_json, ref2_json ) =>\n      ref1 = JSON.parse ref1_json #; ref1 = if ref1.length is 1 then ref1[ 0 ] else ref1\n      ref2 = JSON.parse ref2_json #; ref2 = if ref1.length is 1 then ref2[ 0 ] else ref2\n      return JSON.stringify [ ref1, ref2, ]\n    #.......................................................................................................\n    return null\n\n\n  #=========================================================================================================\n  # VNRs\n  #---------------------------------------------------------------------------------------------------------\n  vnr_as_hollerith: ( vnr ) ->\n    sign_delta  = 0x80000000  ### used to lift negative numbers to non-negative ###\n    u32_width   = 4           ### bytes per element ###\n    vnr_width   = 5           ### maximum elements in VNR vector ###\n    nr_min      = -0x80000000 ### smallest possible VNR element ###\n    nr_max      = +0x7fffffff ### largest possible VNR element ###\n    unless 0 < vnr.length <= vnr_width\n      throw new Error \"^44798^ expected VNR to be between 1 and #{vnr_width} elements long, got length #{vnr.length}\"\n    R           = Buffer.alloc vnr_width * u32_width, 0x00\n    offset      = -u32_width\n    for idx in [ 0 ... vnr_width ]\n      R.writeUInt32BE ( vnr[ idx ] ? 0 ) + sign_delta, ( offset += u32_width )\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  vnr_deepen: ( vnr, extra = 0 ) -> [ vnr..., extra, ]\n\n  #=========================================================================================================\n  # INSERT, UPDATE, DELETE\n  #---------------------------------------------------------------------------------------------------------\n  delete_edges: ( source = null, target = null ) ->\n    if source is null\n      if target is null then  sql = SQL\"delete from edges;\"\n      else                    sql = SQL\"delete from edges where target is $target;\"\n    else\n      if target is null then  sql = SQL\"delete from edges where source = $source;\"\n      else                    sql = SQL\"delete from edges where source = $source and target = $target;\"\n    return @dba.run sql, { source, target, }\n\n  #=========================================================================================================\n  insert_edge: ( source, target, properties ) ->\n    sql = SQL\"insert into edges ( source, target, properties ) values ( ?, ?, ? )\"\n    return @dba.run sql, [ source, target, ( jr properties ), ]\n\n  #---------------------------------------------------------------------------------------------------------\n  upsert_edge: ( source, target, properties ) ->\n    @types.validate.gdb_edge_properties properties\n    sql = SQL\"\"\"\n      insert into edges ( source, target, properties )\n        values ( $source, $target, $properties )\n        on conflict ( source, target ) do update set properties = $properties;\"\"\"\n    return @dba.run sql, { source, target, properties: ( jr properties ), }\n\n  #---------------------------------------------------------------------------------------------------------\n  upmerge_edge: ( source, target, properties ) ->\n    @types.validate.gdb_edge_properties properties\n    sql = SQL\"\"\"\n      insert into edges as e ( source, target, properties )\n        values ( $source, $target, $properties )\n        on conflict ( source, target ) do update set properties = json_patch( e.properties, $properties );\"\"\"\n    return @dba.run sql, { source, target, properties: ( jr properties ), }\n\n  #---------------------------------------------------------------------------------------------------------\n  update_edge: ( source, target, properties ) ->\n    @types.validate.gdb_edge_properties properties\n    sql = SQL\"update edges set properties = json( $properties ) where source = $source and target = $target;\"\n    return @dba.run sql, { source, target, properties: ( jr properties ), }\n\n  #=========================================================================================================\n  insert_node: ( body ) ->\n    @types.validate.gdb_node_body body\n    sql = SQL\"insert into nodes ( body ) values ( ? )\"\n    return @dba.run sql, [ ( jr body ), ]\n\n  #---------------------------------------------------------------------------------------------------------\n  upsert_node: ( body ) ->\n    ### Inserts or updates a node with a given `body`, replacing all existing atrs. ###\n    @types.validate.gdb_node_body body\n    sql = SQL\"\"\"\n      insert into nodes ( body )\n        values ( $body )\n        on conflict ( id ) do update set body = $body;\"\"\"\n    return @dba.run sql, { body: jr body, }\n\n  #---------------------------------------------------------------------------------------------------------\n  upmerge_node: ( body ) ->\n    ### Inserts or merges a node with a given `body`, using [SQLite `json_patch()`\n    function](https://www.sqlite.org/json1.html#jpatch) which is an implementation of [the RFC-7396\n    MergePatch algorithm](https://tools.ietf.org/html/rfc7396). ###\n    @types.validate.gdb_node_body body\n    sql = SQL\"\"\"\n      insert into nodes as n ( body )\n        values ( $body )\n        on conflict ( id ) do update set body = json_patch( n.body, $body );\"\"\"\n    return @dba.run sql, { body: jr body, }\n\n  #---------------------------------------------------------------------------------------------------------\n  update_node: ( body ) ->\n    sql = SQL\"update nodes set body = json( $body ) where id = $id;\"\n    return @dba.run sql, { body: ( jr body ), id: body.id, }\n\n  #---------------------------------------------------------------------------------------------------------\n  delete_node: ( id ) ->\n    throw new Error \"not yet implemented\"\n    sql = SQL\"delete from nodes where id = $id\"\n\n  #=========================================================================================================\n  search_edges_inbound: () ->\n    throw new Error \"not yet implemented\"\n    sql = SQL\"select * from edges where source = ?\"\n\n  #---------------------------------------------------------------------------------------------------------\n  search_edges_outbound: () ->\n    throw new Error \"not yet implemented\"\n    sql = SQL\"select * from edges where target = ?\"\n\n\n  #=========================================================================================================\n  # SEARCH\n  #---------------------------------------------------------------------------------------------------------\n  search_edges: () ->\n    throw new Error \"not yet implemented\"\n    sql = SQL\"\"\"\n      select * from edges where source = ?\n      union\n      select * from edges where target = ?\"\"\"\n\n  #---------------------------------------------------------------------------------------------------------\n  search_node_by_id: () ->\n    throw new Error \"not yet implemented\"\n    ### TAINT instead of 'json_extract(body, '$.id')', use virtual field(?) ###\n    sql = SQL\"select body from nodes where json_extract(body, '$.id') = ?\"\n\n  #---------------------------------------------------------------------------------------------------------\n  search_node: () ->\n    throw new Error \"not yet implemented\"\n    sql = SQL\"select body from nodes where\"\n\n\n  #=========================================================================================================\n  # TRAVERSE\n  #---------------------------------------------------------------------------------------------------------\n  traverse_inbound: () ->\n    throw new Error \"not yet implemented\"\n    sql = SQL\"\"\"\n      with recursive traverse(id) as (\n        select ?\n        union\n        select source from edges join traverse on target = id\n      ) select id from traverse;\"\"\"\n\n  #---------------------------------------------------------------------------------------------------------\n  traverse_outbound: () ->\n    throw new Error \"not yet implemented\"\n    sql = SQL\"\"\"\n      with recursive traverse(id) as (\n        select ?\n        union\n        select target from edges join traverse on source = id\n      ) select id from traverse;\"\"\"\n\n  #---------------------------------------------------------------------------------------------------------\n  traverse: () ->\n    throw new Error \"not yet implemented\"\n    sql = SQL\"\"\"\n      with recursive traverse(id) as (\n        select ?\n        union\n        select source from edges join traverse on target = id\n        union\n        select target from edges join traverse on source = id\n      ) select id from traverse;\"\"\"\n\n  #---------------------------------------------------------------------------------------------------------\n  traverse_with_bodies_inbound: () ->\n    throw new Error \"not yet implemented\"\n    sql = SQL\"\"\"\n    with recursive traverse(x, y, obj) as (\n      select ?, ?, ?\n      union\n      select id, '()', body from nodes join traverse on id = x\n      union\n      select source, '<-', properties from edges join traverse on target = x\n    ) select x, y, obj from traverse;\"\"\"\n\n  #---------------------------------------------------------------------------------------------------------\n  traverse_with_bodies_outbound: () ->\n    throw new Error \"not yet implemented\"\n    sql = SQL\"\"\"\n      with recursive traverse(x, y, obj) as (\n        select ?, ?, ?\n        union\n        select id, '()', body from nodes join traverse on id = x\n        union\n        select target, '->', properties from edges join traverse on source = x\n      ) select x, y, obj from traverse;\"\"\"\n\n  #---------------------------------------------------------------------------------------------------------\n  traverse_with_bodies: () ->\n    throw new Error \"not yet implemented\"\n    sql = SQL\"\"\"\n      with recursive traverse(x, y, obj) as (\n        select ?, ?, ?\n        union\n        select id, '()', body from nodes join traverse on id = x\n        union\n        select source, '<-', properties from edges join traverse on target = x\n        union\n        select target, '->', properties from edges join traverse on source = x\n      ) select x, y, obj from traverse;\"\"\"\n\n\n"
  ]
}