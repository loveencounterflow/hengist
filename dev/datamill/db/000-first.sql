

-- \set ECHO queries

/* ###################################################################################################### */
\ir './_trm.sql'
-- \ir './set-signal-color.sql'
-- \ir './test-begin.sql'
-- \pset pager on
\timing off
\set filename datamill/000-first.sql
\set signal :green

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 1 }———:reset
drop schema if exists DEMO cascade; create schema DEMO;



-- =========================================================================================================
-- DOMAINS
-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 2 }———:reset
-- ### TAINT use intershop.ptv variables to make configurable?
create domain DEMO.positive_integer as integer  check ( value > 0                   );
create domain DEMO.nonempty_text    as text     check ( value ~ '.+'                );
-- create domain DEMO.absolute_path    as text     check ( DEMO.test_absolute_path( value ) );
-- create domain DEMO.topic            as text     check ( DEMO.test_topic( value ) );
-- create domain DEMO.focus            as text     check ( DEMO.test_focus( value ) );

-- comment on domain DEMO.absolute_path is 'Data type for FlowMatic paths (qualified names); must be either a
-- slash (for the root element) or else start with a slash, followed by at least one character other than a
-- slash, not contain any slash directly followed by another slash, and not end in a slash.';


-- =========================================================================================================
--
-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 3 }———:reset
-- ### TAINT find better term than 'rolegroup'
create table DEMO.rolegroups (
    rolegroup   DEMO.nonempty_text  not null  unique,
    comment     DEMO.nonempty_text,
  primary key ( rolegroup ) );

comment on table DEMO.rolegroups is 'XXXXXXXXXXXXXXXXXXXXXX';

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 4 }———:reset
insert into DEMO.rolegroups ( rolegroup, comment ) values
  ( 'rule',         'XXX' ),
  -- ### TAINT find better term than 'declaration' ('rules' are likewise 'declared')
  ( 'declaration',  'XXX' );

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 5 }———:reset
create table DEMO.roles (
    rolegroup   DEMO.nonempty_text    not null references DEMO.rolegroups ( rolegroup ),
    priority    DEMO.positive_integer not null,
    role        DEMO.nonempty_text    not null  unique,
    comment     DEMO.nonempty_text,
  primary key ( role ) );
create unique index on DEMO.roles ( role, priority );
comment on table DEMO.roles is 'Provides roles of FlowMatic components.';

-- ---------------------------------------------------------------------------------------------------------
\echo :signal ———{ :filename 6 }———:reset
insert into DEMO.roles ( rolegroup, priority, role, comment ) values
  ( 'declaration',  1,  'action',     'xxxx' ),
  ( 'declaration',  2,  'state',      'xxxx' ),
  ( 'declaration',  3,  'component',  'xxxx' ),
  ( 'rule',         4,  'premise',    'xxxx' ),
  ( 'rule',         5,  'trigger',    'xxxx' ),
  ( 'rule',         6,  'effect',     'xxxx' ),
  ( 'rule',         7,  'move',       'xxxx' );

-- -- ---------------------------------------------------------------------------------------------------------
-- \echo :signal ———{ :filename 8 }———:reset
-- create function DEMO._is_rulid( ¶rulid bigint ) returns boolean stable language sql as $$
--   select exists ( select 1 from DEMO.rules where rulid = ¶rulid limit 1 ); $$;

-- -- ---------------------------------------------------------------------------------------------------------
-- \echo :signal ———{ :filename 9 }———:reset
-- -- ### TAINT add check that sigil matches role
-- create table DEMO.parts (
--     partid    bigint                  generated by default as identity primary key,
--     role      text                    not null  references DEMO.roles ( role ),
--     path      DEMO.absolute_path      not null,
--     rulid     DEMO.positive_integer,
--     comment   DEMO.nonempty_text,
--     constraint "xxx" check (
--       -- ### TAINT use rolegroup instead of listing terms
--       ( role in ( 'premise', 'trigger', 'effect', 'move' ) and DEMO._is_rulid( rulid ) )
--         or
--       ( role in ( 'component', 'state', 'action' ) and ( rulid is null ) ) )
--     );

-- -- thx to https://stackoverflow.com/a/8289253/7568091 (as usual)
-- -- thx to https://dba.stackexchange.com/a/9760/126933 (as usual)
-- -- ### TAINT think about best ordering of fields
-- create unique index "unique (role,path) where rulid is null" on
--   DEMO.parts ( role, path ) where rulid is null;
-- create unique index "unique (role,path,rulid) where rulid is not null" on
--   DEMO.parts ( role, path, rulid ) where rulid is not null;

-- comment on table DEMO.parts is 'XXXXXXXXXXXXXXXXXXXXXX';


-- =========================================================================================================
--

select * from CATALOG.catalog where schema = 'demo';

/* ###################################################################################################### */
\echo :red ———{ :filename 15 }———:reset
\quit







