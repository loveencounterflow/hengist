{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/main.benchmarks.coffee"
  ],
  "names": [],
  "mappings": "AACA;EAAA;AAAA,MAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,IAAA,EAAA,KAAA,EAAA,KAAA,EAAA,MAAA,EAAA,MAAA,EAAA,KAAA,EAAA,IAAA,EAAA,KAAA,EAAA,KAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,EAAA,GAAA,EAAA,EAAA,EAAA,aAAA,EAAA,GAAA,EAAA,OAAA,EAAA,OAAA,EAAA,IAAA,EAAA,QAAA,EAAA,IAAA,EAAA,OAAA;;;EAIA,GAAA,GAA4B,OAAA,CAAQ,KAAR;;EAC5B,KAAA,GAA4B;;EAC5B,GAAA,GAA4B,GAAG,CAAC;;EAChC,KAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,OAAf,EAA4B,KAA5B;;EAC5B,KAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,OAAf,EAA4B,KAA5B;;EAC5B,OAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,SAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,IAAI,CAAC,IAAT,CAAc,GAAd;;EAC5B,CAAA,CAAE,EAAF,CAAA,GAA4B,GAA5B;;EACA,MAAA,GAA4B,MAAM,CAAC;;EACnC,KAAA,GAA4B,QAAA,CAAE,MAAF,EAAU,CAAV,CAAA;WAAiB,UAAA,CAAW,CAAX,EAAc,MAAA,GAAS,IAAvB;EAAjB;;EAC5B,KAAA,GAA4B,aAlB5B;;;EAoBA,IAAC,CAAA,KAAD,GAA4B,IAAI,CAAE,OAAA,CAAQ,WAAR,CAAF,CAAuB,CAAC,SAA5B,CAAA;;EAC5B,CAAA,CAAE,GAAF,EACE,QADF,EAEE,IAFF,EAGE,OAHF,CAAA,GAG4B,IAAC,CAAA,KAAK,CAAC,MAAP,CAAA,CAH5B,EArBA;;;EA0BA,EAAA,GAA4B,OAAA,CAAQ,yBAAR,EA1B5B;;;;EA6BA,OAAA,GAA4B,CAAA,GAAI;;EAChC,aAAA,GAA4B,QAAA,CAAE,EAAF,CAAA;WAAU,IAAI,CAAC,GAAL,CAAA,CAAA,GAAa,EAAb,GAAkB;EAA5B;;EAC5B,GAAA,GAA4B,CAAE,OAAA,CAAQ,IAAR,CAAF,CAAgB,CAAC;;EAC7C,IAAA,GAA4B,OAAA,CAAQ,MAAR,EAhC5B;;;EAkCA,MAAA,GACE;IAAA,EAAA,EAAoB,KAApB;IACA,MAAA,EAAoB,EADpB;IAEA,aAAA,EAAoB;EAFpB;;EAnCF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA",
  "sourcesContent": [
    "\n'use strict'\n\n\n############################################################################################################\nCND                       = require 'cnd'\nbadge                     = 'DISCONTINUOUS-RANGES/BENCHMARKS'\nrpr                       = CND.rpr\ndebug                     = CND.get_logger 'debug',     badge\nalert                     = CND.get_logger 'alert',     badge\nwhisper                   = CND.get_logger 'whisper',   badge\nwarn                      = CND.get_logger 'warn',      badge\nhelp                      = CND.get_logger 'help',      badge\nurge                      = CND.get_logger 'urge',      badge\ninfo                      = CND.get_logger 'info',      badge\necho                      = CND.echo.bind CND\n{ jr, }                   = CND\nassign                    = Object.assign\nafter                     = ( time_s, f ) -> setTimeout f, time_s * 1000\ndefer                     = setImmediate\n#...........................................................................................................\n@types                    = new ( require 'intertype' ).Intertype()\n{ isa\n  validate\n  cast\n  type_of }               = @types.export()\n#...........................................................................................................\nBM                        = require '../../../lib/benchmarks'\n# DATA                      = require '../data-providers'\n#...........................................................................................................\ntimeout                   = 3 * 1000\nlimit_reached             = ( t0 ) -> Date.now() - t0 > timeout\nFSP                       = ( require 'fs' ).promises\nPATH                      = require 'path'\n#...........................................................................................................\nassets =\n  ok:                 false\n  probes:             []\n  segment_count:      0\n\n\n\n# #-----------------------------------------------------------------------------------------------------------\n# prepare = ( n ) -> new Promise ( resolve ) ->\n#   rnd               = CND.random_integer.bind CND\n#   probe_length_min  = 1\n#   probe_length_max  = 100\n#   first_cid         = 0x0000\n#   last_cid          = 0x00ff\n#   Δ_min             = 0x00\n#   Δ_max             = 0x10\n#   return resolve() if assets.ok\n#   for probe_nr in [ 1 .. n ]\n#     segments = []\n#     for segment_nr in [ 1 .. ( rnd probe_length_min, probe_length_max ) ]\n#       lo          = rnd first_cid, last_cid\n#       hi          = lo + rnd Δ_min, Δ_max\n#       [ lo, hi, ] = [ hi, lo, ] if lo > hi\n#       segments.push [ lo, hi, ]\n#       assets.segment_count++\n#     assets.probes.push segments\n#   assets.ok = true\n#   resolve()\n#   return null\n\n\n# #===========================================================================================================\n# #\n# #-----------------------------------------------------------------------------------------------------------\n# @merge_dra_oop = ( n, show, name ) -> new Promise ( resolve ) =>\n#   DRA = require './discontinuous-range-arithmetics'\n#   await prepare n\n#   #.........................................................................................................\n#   resolve => new Promise merge = ( resolve ) =>\n#     for segments in assets.probes\n#       urange = new DRA.Urange()\n#       for segment in segments\n#         urange = urange.union segment\n#       result = urange.as_lists()\n#       info ( CND.grey segments )\n#       info ( CND.yellow result )\n#     resolve assets.segment_count\n#     return null\n#   #.........................................................................................................\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @merge_dra_fun = ( n, show, name ) -> new Promise ( resolve ) =>\n#   DRA = require './discontinuous-range-arithmetics'\n#   await prepare n\n#   #.........................................................................................................\n#   resolve => new Promise merge = ( resolve ) =>\n#     for segments in assets.probes\n#       urange = DRA.new_range()\n#       for segment in segments\n#         urange = DRA.union urange, segment\n#       info ( CND.grey segments )\n#       info ( CND.yellow urange )\n#     resolve assets.segment_count\n#     return null\n#   #.........................................................................................................\n#   return null\n\n\n\n# #===========================================================================================================\n# #\n# #-----------------------------------------------------------------------------------------------------------\n# @benchmark = ->\n#   # always_use_fresh_words    = false\n#   bench       = BM.new_benchmarks()\n#   # n           = 1e6\n#   n           = 10\n#   timeout     = n / 50e3 * 1000 + ( 2 * 1000 )\n#   show        = false\n#   show        = n < 21\n#   repetitions = 1\n#   # await BM.benchmark n, show, @\n#   test_names = [\n#     'merge_dra_oop'\n#     'merge_dra_fun'\n#     ]\n#   for _ in [ 1 .. repetitions ]\n#     CND.shuffle test_names\n#     for test_name in test_names\n#       await BM.benchmark bench, n, show, @, test_name\n#     echo()\n#   BM.show_totals bench\n#   return null\n\n# # commander                          heap-benchmark fontmirror interplot svgttf mingkwai-typesetter\n# ############################################################################################################\n# if module is require.main then do =>\n#   # demo_parse()\n#   await @benchmark()\n#   return null\n\n"
  ]
}